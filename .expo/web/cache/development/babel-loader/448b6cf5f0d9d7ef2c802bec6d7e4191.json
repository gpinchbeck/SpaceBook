{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { calculatePosition } from \"./calculatePosition\";\nimport { useCallback, useRef, useState } from 'react';\nimport { useCloseOnScroll } from \"./useCloseOnScroll\";\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\nvar visualViewport = typeof window !== 'undefined' && window.visualViewport;\nexport function useOverlayPosition(props) {\n  var direction = isRTL() ? 'rtl' : undefined;\n  var targetRef = props.targetRef,\n      overlayRef = props.overlayRef,\n      _props$scrollRef = props.scrollRef,\n      scrollRef = _props$scrollRef === void 0 ? overlayRef : _props$scrollRef,\n      _props$placement = props.placement,\n      placement = _props$placement === void 0 ? 'bottom' : _props$placement,\n      _props$containerPaddi = props.containerPadding,\n      containerPadding = _props$containerPaddi === void 0 ? 12 : _props$containerPaddi,\n      _props$shouldFlip = props.shouldFlip,\n      shouldFlip = _props$shouldFlip === void 0 ? true : _props$shouldFlip,\n      _props$boundaryElemen = props.boundaryElement,\n      boundaryElement = _props$boundaryElemen === void 0 ? typeof document !== 'undefined' ? document.body : null : _props$boundaryElemen,\n      _props$offset = props.offset,\n      offset = _props$offset === void 0 ? 0 : _props$offset,\n      _props$crossOffset = props.crossOffset,\n      crossOffset = _props$crossOffset === void 0 ? 0 : _props$crossOffset,\n      _props$shouldUpdatePo = props.shouldUpdatePosition,\n      shouldUpdatePosition = _props$shouldUpdatePo === void 0 ? true : _props$shouldUpdatePo,\n      _props$isOpen = props.isOpen,\n      isOpen = _props$isOpen === void 0 ? true : _props$isOpen,\n      _props$shouldOverlapW = props.shouldOverlapWithTrigger,\n      shouldOverlapWithTrigger = _props$shouldOverlapW === void 0 ? false : _props$shouldOverlapW,\n      onClose = props.onClose;\n\n  var _useState = useState({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      position = _useState2[0],\n      setPosition = _useState2[1];\n\n  var deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, shouldOverlapWithTrigger];\n  var updatePosition = useCallback(function () {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {\n      return;\n    }\n\n    setPosition(calculatePosition({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current,\n      padding: containerPadding,\n      shouldFlip: shouldFlip,\n      boundaryElement: boundaryElement,\n      offset: offset,\n      crossOffset: crossOffset,\n      shouldOverlapWithTrigger: shouldOverlapWithTrigger\n    }));\n  }, deps);\n  useLayoutEffect(updatePosition, deps);\n  useResize(updatePosition);\n  var isResizing = useRef(false);\n  useLayoutEffect(function () {\n    var timeout;\n\n    var onResize = function onResize() {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(function () {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n\n    visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.addEventListener('resize', onResize);\n    return function () {\n      visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n  var close = useCallback(function () {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen: isOpen,\n    onClose: onClose ? close : undefined\n  });\n  return {\n    rendered: true,\n    overlayProps: {\n      style: _objectSpread(_objectSpread({\n        position: 'absolute',\n        zIndex: 100000\n      }, position.position), {}, {\n        maxHeight: position.maxHeight\n      })\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition: updatePosition\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(function () {\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n\n  return position.replace('start', 'left').replace('end', 'right');\n}","map":{"version":3,"mappings":"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","names":["calculatePosition","useCallback","useRef","useState","useCloseOnScroll","isRTL","useLayoutEffect","visualViewport","window","useOverlayPosition","props","direction","undefined","targetRef","overlayRef","scrollRef","placement","containerPadding","shouldFlip","boundaryElement","document","body","offset","crossOffset","shouldUpdatePosition","isOpen","shouldOverlapWithTrigger","onClose","position","arrowOffsetLeft","arrowOffsetTop","maxHeight","setPosition","deps","current","updatePosition","translateRTL","overlayNode","targetNode","scrollNode","padding","useResize","isResizing","timeout","onResize","clearTimeout","setTimeout","addEventListener","removeEventListener","close","triggerRef","rendered","overlayProps","style","zIndex","arrowProps","left","top","replace"],"sources":["D:/Users/georg/Desktop/MAD/SpaceBook/node_modules/@react-native-aria/overlays/lib/module/web/overlays/src/useOverlayPosition.js"],"sourcesContent":["//@ts-nocheck\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { calculatePosition } from './calculatePosition';\nimport { useCallback, useRef, useState } from 'react';\nimport { useCloseOnScroll } from './useCloseOnScroll';\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\n// @ts-ignore\nlet visualViewport = typeof window !== 'undefined' && window.visualViewport;\n/**\n * Handles positioning overlays like popovers and menus relative to a trigger\n * element, and updating the position when the window resizes.\n */\n\nexport function useOverlayPosition(props) {\n  const direction = isRTL() ? 'rtl' : undefined;\n  let {\n    targetRef,\n    overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom',\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    shouldOverlapWithTrigger = false,\n    onClose\n  } = props;\n  let [position, setPosition] = useState({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined\n  });\n  let deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, shouldOverlapWithTrigger];\n  let updatePosition = useCallback(() => {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {\n      return;\n    }\n\n    setPosition(calculatePosition({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current,\n      padding: containerPadding,\n      shouldFlip,\n      boundaryElement,\n      offset,\n      crossOffset,\n      shouldOverlapWithTrigger\n    }));\n  }, deps); // Update position when anything changes\n\n  useLayoutEffect(updatePosition, deps); // Update position on window resize\n\n  useResize(updatePosition); // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout;\n\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n\n    visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.addEventListener('resize', onResize);\n    return () => {\n      visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]); // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose ? close : undefined\n  });\n  return {\n    rendered: true,\n    overlayProps: {\n      style: {\n        position: 'absolute',\n        zIndex: 100000,\n        // should match the z-index in ModalTrigger\n        ...position.position,\n        maxHeight: position.maxHeight\n      }\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n\n  return position.replace('start', 'left').replace('end', 'right');\n}\n//# sourceMappingURL=useOverlayPosition.js.map"]},"metadata":{},"sourceType":"module"}