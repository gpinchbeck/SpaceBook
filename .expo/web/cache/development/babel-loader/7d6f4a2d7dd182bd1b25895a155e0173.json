{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport getCss from 'dom-helpers/style';\nimport getOffset from 'dom-helpers/query/offset';\nimport getPosition from 'dom-helpers/query/position';\nimport getScrollLeft from 'dom-helpers/query/scrollLeft';\nimport getScrollTop from 'dom-helpers/query/scrollTop';\nimport ownerDocument from 'dom-helpers/ownerDocument';\nvar AXIS = {\n  top: 'top',\n  bottom: 'top',\n  left: 'left',\n  right: 'left'\n};\nvar FLIPPED_DIRECTION = {\n  top: 'bottom',\n  bottom: 'top',\n  left: 'right',\n  right: 'left'\n};\nvar CROSS_AXIS = {\n  top: 'left',\n  left: 'top'\n};\nvar AXIS_SIZE = {\n  top: 'height',\n  left: 'width'\n};\nvar PARSED_PLACEMENT_CACHE = {};\nvar visualViewport = typeof window !== 'undefined' && window.visualViewport;\n\nfunction getContainerDimensions(containerNode) {\n  var width = 0,\n      height = 0,\n      top = 0,\n      left = 0;\n  var scroll = {};\n\n  if (containerNode.tagName === 'BODY') {\n    var _visualViewport$width, _visualViewport$heigh;\n\n    width = (_visualViewport$width = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _visualViewport$width !== void 0 ? _visualViewport$width : document.documentElement.clientWidth;\n    height = (_visualViewport$heigh = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _visualViewport$heigh !== void 0 ? _visualViewport$heigh : document.documentElement.clientHeight;\n    scroll.top = getScrollTop(ownerDocument(containerNode).documentElement) || getScrollTop(containerNode);\n    scroll.left = getScrollLeft(ownerDocument(containerNode).documentElement) || getScrollLeft(containerNode);\n  } else {\n    var _getOffset = getOffset(containerNode);\n\n    width = _getOffset.width;\n    height = _getOffset.height;\n    top = _getOffset.top;\n    left = _getOffset.left;\n    scroll.top = getScrollTop(containerNode);\n    scroll.left = getScrollLeft(containerNode);\n  }\n\n  return {\n    width: width,\n    height: height,\n    scroll: scroll,\n    top: top,\n    left: left\n  };\n}\n\nfunction getScroll(node) {\n  return {\n    top: node.scrollTop,\n    left: node.scrollLeft,\n    width: node.scrollWidth,\n    height: node.scrollHeight\n  };\n}\n\nfunction getDelta(axis, offset, size, containerDimensions, padding) {\n  var containerScroll = containerDimensions.scroll[axis];\n  var containerHeight = containerDimensions[AXIS_SIZE[axis]];\n  var startEdgeOffset = offset - padding - containerScroll;\n  var endEdgeOffset = offset + padding - containerScroll + size;\n\n  if (startEdgeOffset < 0) {\n    return -startEdgeOffset;\n  } else if (endEdgeOffset > containerHeight) {\n    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);\n  } else {\n    return 0;\n  }\n}\n\nfunction getMargins(node) {\n  var style = window.getComputedStyle(node);\n  return {\n    top: parseInt(style.marginTop, 10) || 0,\n    bottom: parseInt(style.marginBottom, 10) || 0,\n    left: parseInt(style.marginLeft, 10) || 0,\n    right: parseInt(style.marginRight, 10) || 0\n  };\n}\n\nfunction parsePlacement(input) {\n  if (PARSED_PLACEMENT_CACHE[input]) {\n    return PARSED_PLACEMENT_CACHE[input];\n  }\n\n  var _input$split = input.split(' '),\n      _input$split2 = _slicedToArray(_input$split, 2),\n      placement = _input$split2[0],\n      crossPlacement = _input$split2[1];\n\n  var axis = AXIS[placement] || 'right';\n  var crossAxis = CROSS_AXIS[axis];\n\n  if (!AXIS[crossPlacement]) {\n    crossPlacement = 'center';\n  }\n\n  var size = AXIS_SIZE[axis];\n  var crossSize = AXIS_SIZE[crossAxis];\n  PARSED_PLACEMENT_CACHE[input] = {\n    placement: placement,\n    crossPlacement: crossPlacement,\n    axis: axis,\n    crossAxis: crossAxis,\n    size: size,\n    crossSize: crossSize\n  };\n  return PARSED_PLACEMENT_CACHE[input];\n}\n\nfunction computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned) {\n  var placement = placementInfo.placement,\n      crossPlacement = placementInfo.crossPlacement,\n      axis = placementInfo.axis,\n      crossAxis = placementInfo.crossAxis,\n      size = placementInfo.size,\n      crossSize = placementInfo.crossSize;\n  var position = {};\n  position[crossAxis] = childOffset[crossAxis];\n\n  if (crossPlacement === 'center') {\n    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;\n  } else if (crossPlacement !== crossAxis) {\n    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];\n  }\n\n  position[crossAxis] += crossOffset;\n  var minViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2 - overlaySize[crossSize];\n  var maxViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2;\n  position[crossAxis] = Math.min(Math.max(minViablePosition, position[crossAxis]), maxViablePosition);\n\n  if (placement === axis) {\n    var containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[size];\n    position[FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);\n  } else {\n    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);\n  }\n\n  return position;\n}\n\nfunction getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {\n  return position.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - (containerOffsetWithBoundary.top + position.top) - (margins.top + margins.bottom + padding)) : Math.max(0, childOffset.top + containerOffsetWithBoundary.top - (boundaryDimensions.top + boundaryDimensions.scroll.top) - (margins.top + margins.bottom + padding));\n}\n\nfunction getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {\n  var placement = placementInfo.placement,\n      axis = placementInfo.axis,\n      size = placementInfo.size;\n\n  if (placement === axis) {\n    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[FLIPPED_DIRECTION[axis]] - padding);\n  }\n\n  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[FLIPPED_DIRECTION[axis]] - padding);\n}\n\nexport function calculatePositionInternal(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, shouldOverlapWithTrigger) {\n  var placementInfo = parsePlacement(placementInput);\n  var _placementInfo = placementInfo,\n      size = _placementInfo.size,\n      crossAxis = _placementInfo.crossAxis,\n      crossSize = _placementInfo.crossSize,\n      placement = _placementInfo.placement,\n      crossPlacement = _placementInfo.crossPlacement,\n      axis = _placementInfo.axis;\n  var position = computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n  var normalizedOffset = offset;\n  var space = getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo);\n\n  if (flip && scrollSize[size] > space) {\n    var flippedPlacementInfo = parsePlacement(FLIPPED_DIRECTION[placement] + \" \" + crossPlacement);\n    var flippedPosition = computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n    var flippedSpace = getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo);\n\n    if (flippedSpace > space) {\n      placementInfo = flippedPlacementInfo;\n      position = flippedPosition;\n      normalizedOffset = offset;\n    }\n  }\n\n  var delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);\n  position[crossAxis] += delta;\n  var maxHeight = getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);\n  overlaySize.height = Math.min(overlaySize.height, maxHeight);\n  position = computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n  delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);\n  position[crossAxis] += delta;\n  var arrowPosition = {};\n  arrowPosition[crossAxis] = childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;\n\n  if (shouldOverlapWithTrigger) {\n    position[FLIPPED_DIRECTION[placementInfo.placement]] = position[FLIPPED_DIRECTION[placementInfo.placement]] - childOffset[size];\n  }\n\n  return {\n    position: position,\n    maxHeight: maxHeight,\n    arrowOffsetLeft: arrowPosition.left,\n    arrowOffsetTop: arrowPosition.top,\n    placement: placementInfo.placement\n  };\n}\nexport function calculatePosition(opts) {\n  var placement = opts.placement,\n      targetNode = opts.targetNode,\n      overlayNode = opts.overlayNode,\n      scrollNode = opts.scrollNode,\n      padding = opts.padding,\n      shouldFlip = opts.shouldFlip,\n      boundaryElement = opts.boundaryElement,\n      offset = opts.offset,\n      crossOffset = opts.crossOffset,\n      shouldOverlapWithTrigger = opts.shouldOverlapWithTrigger;\n  var container = overlayNode.offsetParent || document.body;\n  var isBodyContainer = container.tagName === 'BODY';\n  var containerPositionStyle = window.getComputedStyle(container).position;\n  var isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== 'static';\n  var childOffset = isBodyContainer ? getOffset(targetNode) : getPosition(targetNode, container);\n\n  if (!isBodyContainer) {\n    childOffset.top += parseInt(getCss(targetNode, 'marginTop'), 10) || 0;\n    childOffset.left += parseInt(getCss(targetNode, 'marginLeft'), 10) || 0;\n  }\n\n  var overlaySize = getOffset(overlayNode);\n  var margins = getMargins(overlayNode);\n  overlaySize.width += margins.left + margins.right;\n  overlaySize.height += margins.top + margins.bottom;\n  var scrollSize = getScroll(scrollNode);\n  var boundaryDimensions = getContainerDimensions(boundaryElement);\n  var containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? getOffset(container) : getPosition(container, boundaryElement);\n  return calculatePositionInternal(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, shouldOverlapWithTrigger);\n}","map":{"version":3,"mappings":"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","names":["getCss","getOffset","getPosition","getScrollLeft","getScrollTop","ownerDocument","AXIS","top","bottom","left","right","FLIPPED_DIRECTION","CROSS_AXIS","AXIS_SIZE","PARSED_PLACEMENT_CACHE","visualViewport","window","getContainerDimensions","containerNode","width","height","scroll","tagName","_visualViewport$width","_visualViewport$heigh","document","documentElement","clientWidth","clientHeight","getScroll","node","scrollTop","scrollLeft","scrollWidth","scrollHeight","getDelta","axis","offset","size","containerDimensions","padding","containerScroll","containerHeight","startEdgeOffset","endEdgeOffset","Math","max","getMargins","style","getComputedStyle","parseInt","marginTop","marginBottom","marginLeft","marginRight","parsePlacement","input","split","placement","crossPlacement","crossAxis","crossSize","computePosition","childOffset","boundaryDimensions","overlaySize","placementInfo","crossOffset","containerOffsetWithBoundary","isContainerPositioned","position","minViablePosition","maxViablePosition","min","floor","getMaxHeight","margins","getAvailableSpace","calculatePositionInternal","placementInput","scrollSize","flip","shouldOverlapWithTrigger","normalizedOffset","space","flippedPlacementInfo","flippedPosition","flippedSpace","delta","maxHeight","arrowPosition","arrowOffsetLeft","arrowOffsetTop","calculatePosition","opts","targetNode","overlayNode","scrollNode","shouldFlip","boundaryElement","container","offsetParent","body","isBodyContainer","containerPositionStyle"],"sources":["D:/Users/georg/Desktop/MAD/SpaceBook/node_modules/@react-native-aria/overlays/lib/module/web/overlays/src/calculatePosition.js"],"sourcesContent":["// @ts-nocheck\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport getCss from 'dom-helpers/style';\nimport getOffset from 'dom-helpers/query/offset';\nimport getPosition from 'dom-helpers/query/position';\nimport getScrollLeft from 'dom-helpers/query/scrollLeft';\nimport getScrollTop from 'dom-helpers/query/scrollTop';\nimport ownerDocument from 'dom-helpers/ownerDocument';\nconst AXIS = {\n  top: 'top',\n  bottom: 'top',\n  left: 'left',\n  right: 'left'\n};\nconst FLIPPED_DIRECTION = {\n  top: 'bottom',\n  bottom: 'top',\n  left: 'right',\n  right: 'left'\n};\nconst CROSS_AXIS = {\n  top: 'left',\n  left: 'top'\n};\nconst AXIS_SIZE = {\n  top: 'height',\n  left: 'width'\n};\nconst PARSED_PLACEMENT_CACHE = {}; // @ts-ignore\n\nlet visualViewport = typeof window !== 'undefined' && window.visualViewport;\n\nfunction getContainerDimensions(containerNode) {\n  let width = 0,\n      height = 0,\n      top = 0,\n      left = 0;\n  let scroll = {};\n\n  if (containerNode.tagName === 'BODY') {\n    var _visualViewport$width, _visualViewport$heigh;\n\n    width = (_visualViewport$width = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _visualViewport$width !== void 0 ? _visualViewport$width : document.documentElement.clientWidth;\n    height = (_visualViewport$heigh = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _visualViewport$heigh !== void 0 ? _visualViewport$heigh : document.documentElement.clientHeight;\n    scroll.top = getScrollTop(ownerDocument(containerNode).documentElement) || getScrollTop(containerNode);\n    scroll.left = getScrollLeft(ownerDocument(containerNode).documentElement) || getScrollLeft(containerNode);\n  } else {\n    ({\n      width,\n      height,\n      top,\n      left\n    } = getOffset(containerNode));\n    scroll.top = getScrollTop(containerNode);\n    scroll.left = getScrollLeft(containerNode);\n  }\n\n  return {\n    width,\n    height,\n    scroll,\n    top,\n    left\n  };\n}\n\nfunction getScroll(node) {\n  return {\n    top: node.scrollTop,\n    left: node.scrollLeft,\n    width: node.scrollWidth,\n    height: node.scrollHeight\n  };\n}\n\nfunction getDelta(axis, offset, size, containerDimensions, padding) {\n  let containerScroll = containerDimensions.scroll[axis];\n  let containerHeight = containerDimensions[AXIS_SIZE[axis]];\n  let startEdgeOffset = offset - padding - containerScroll;\n  let endEdgeOffset = offset + padding - containerScroll + size;\n\n  if (startEdgeOffset < 0) {\n    return -startEdgeOffset;\n  } else if (endEdgeOffset > containerHeight) {\n    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);\n  } else {\n    return 0;\n  }\n}\n\nfunction getMargins(node) {\n  let style = window.getComputedStyle(node);\n  return {\n    top: parseInt(style.marginTop, 10) || 0,\n    bottom: parseInt(style.marginBottom, 10) || 0,\n    left: parseInt(style.marginLeft, 10) || 0,\n    right: parseInt(style.marginRight, 10) || 0\n  };\n}\n\nfunction parsePlacement(input) {\n  if (PARSED_PLACEMENT_CACHE[input]) {\n    return PARSED_PLACEMENT_CACHE[input];\n  }\n\n  let [placement, crossPlacement] = input.split(' ');\n  let axis = AXIS[placement] || 'right';\n  let crossAxis = CROSS_AXIS[axis];\n\n  if (!AXIS[crossPlacement]) {\n    crossPlacement = 'center';\n  }\n\n  let size = AXIS_SIZE[axis];\n  let crossSize = AXIS_SIZE[crossAxis];\n  PARSED_PLACEMENT_CACHE[input] = {\n    placement,\n    crossPlacement,\n    axis,\n    crossAxis,\n    size,\n    crossSize\n  };\n  return PARSED_PLACEMENT_CACHE[input];\n}\n\nfunction computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned) {\n  let {\n    placement,\n    crossPlacement,\n    axis,\n    crossAxis,\n    size,\n    crossSize\n  } = placementInfo;\n  let position = {}; // button position\n\n  position[crossAxis] = childOffset[crossAxis];\n\n  if (crossPlacement === 'center') {\n    //  + (button size / 2) - (overlay size / 2)\n    // at this point the overlay center should match the button center\n    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;\n  } else if (crossPlacement !== crossAxis) {\n    //  + (button size) - (overlay size)\n    // at this point the overlay bottom should match the button bottom\n    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];\n  }\n  /* else {\n   the overlay top should match the button top\n  } */\n  // add the crossOffset from props\n\n\n  position[crossAxis] += crossOffset; // this is button center position - the overlay size + half of the button to align bottom of overlay with button center\n\n  let minViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2 - overlaySize[crossSize]; // this is button position of center, aligns top of overlay with button center\n\n  let maxViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2; // clamp it into the range of the min/max positions\n\n  position[crossAxis] = Math.min(Math.max(minViablePosition, position[crossAxis]), maxViablePosition); // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.\n\n  if (placement === axis) {\n    // If the container is positioned (non-static), then we use the container's actual\n    // height, as `bottom` will be relative to this height.  But if the container is static,\n    // then it can only be the `document.body`, and `bottom` will be relative to _its_\n    // container, which should be as large as boundaryDimensions.\n    const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[size];\n    position[FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);\n  } else {\n    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);\n  }\n\n  return position;\n}\n\nfunction getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {\n  return position.top != null // We want the distance between the top of the overlay to the bottom of the boundary\n  ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - ( // this is the bottom of the boundary\n  containerOffsetWithBoundary.top + position.top) // this is the top of the overlay\n  - (margins.top + margins.bottom + padding) // save additional space for margin and padding\n  ) // We want the distance between the top of the trigger to the top of the boundary\n  : Math.max(0, childOffset.top + containerOffsetWithBoundary.top - ( // this is the top of the trigger\n  boundaryDimensions.top + boundaryDimensions.scroll.top) // this is the top of the boundary\n  - (margins.top + margins.bottom + padding) // save additional space for margin and padding\n  );\n}\n\nfunction getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {\n  let {\n    placement,\n    axis,\n    size\n  } = placementInfo;\n\n  if (placement === axis) {\n    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[FLIPPED_DIRECTION[axis]] - padding);\n  }\n\n  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[FLIPPED_DIRECTION[axis]] - padding);\n}\n\nexport function calculatePositionInternal(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, shouldOverlapWithTrigger) {\n  let placementInfo = parsePlacement(placementInput);\n  let {\n    size,\n    crossAxis,\n    crossSize,\n    placement,\n    crossPlacement,\n    axis\n  } = placementInfo;\n  let position = computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n  let normalizedOffset = offset;\n  let space = getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo); // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip\n\n  if (flip && scrollSize[size] > space) {\n    let flippedPlacementInfo = parsePlacement(`${FLIPPED_DIRECTION[placement]} ${crossPlacement}`);\n    let flippedPosition = computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n    let flippedSpace = getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo); // If the available space for the flipped position is greater than the original available space, flip.\n\n    if (flippedSpace > space) {\n      placementInfo = flippedPlacementInfo;\n      position = flippedPosition;\n      normalizedOffset = offset;\n    }\n  }\n\n  let delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);\n  position[crossAxis] += delta;\n  let maxHeight = getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);\n  overlaySize.height = Math.min(overlaySize.height, maxHeight);\n  position = computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n  delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);\n  position[crossAxis] += delta;\n  let arrowPosition = {};\n  arrowPosition[crossAxis] = childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;\n\n  if (shouldOverlapWithTrigger) {\n    position[FLIPPED_DIRECTION[placementInfo.placement]] = position[FLIPPED_DIRECTION[placementInfo.placement]] - childOffset[size];\n  }\n\n  return {\n    position,\n    maxHeight: maxHeight,\n    arrowOffsetLeft: arrowPosition.left,\n    arrowOffsetTop: arrowPosition.top,\n    placement: placementInfo.placement\n  };\n}\n/**\n * Determines where to place the overlay with regards to the target and the position of an optional indicator.\n */\n\nexport function calculatePosition(opts) {\n  let {\n    placement,\n    targetNode,\n    overlayNode,\n    scrollNode,\n    padding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    shouldOverlapWithTrigger\n  } = opts;\n  let container = overlayNode.offsetParent || document.body;\n  let isBodyContainer = container.tagName === 'BODY';\n  const containerPositionStyle = window.getComputedStyle(container).position;\n  let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== 'static';\n  let childOffset = isBodyContainer ? getOffset(targetNode) : getPosition(targetNode, container);\n\n  if (!isBodyContainer) {\n    childOffset.top += parseInt(getCss(targetNode, 'marginTop'), 10) || 0;\n    childOffset.left += parseInt(getCss(targetNode, 'marginLeft'), 10) || 0;\n  }\n\n  let overlaySize = getOffset(overlayNode);\n  let margins = getMargins(overlayNode);\n  overlaySize.width += margins.left + margins.right;\n  overlaySize.height += margins.top + margins.bottom;\n  let scrollSize = getScroll(scrollNode);\n  let boundaryDimensions = getContainerDimensions(boundaryElement);\n  let containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? getOffset(container) : getPosition(container, boundaryElement);\n  return calculatePositionInternal(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, shouldOverlapWithTrigger);\n}\n//# sourceMappingURL=calculatePosition.js.map"]},"metadata":{},"sourceType":"module"}