{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport invariant from 'invariant';\nimport { CameraType, ImageType } from \"./Camera.types\";\nimport * as CapabilityUtils from \"./WebCapabilityUtils\";\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from \"./WebConstants\";\nimport { requestUserMediaAsync } from \"./WebUserMediaManager\";\nexport function getImageSize(videoWidth, videoHeight, scale) {\n  var width = videoWidth * scale;\n  var ratio = videoWidth / width;\n  var height = videoHeight / ratio;\n  return {\n    width: width,\n    height: height\n  };\n}\nexport function toDataURL(canvas, imageType, quality) {\n  invariant(Object.values(ImageType).includes(imageType), \"expo-camera: \" + imageType + \" is not a valid ImageType. Expected a string from: \" + Object.values(ImageType).join(', '));\n  var format = ImageTypeFormat[imageType];\n\n  if (imageType === ImageType.jpg) {\n    invariant(quality <= 1 && quality >= 0, \"expo-camera: \" + quality + \" is not a valid image quality. Expected a number from 0...1\");\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\nexport function hasValidConstraints(preferredCameraType, width, height) {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCameraPictureOptions(config) {\n  var captureOptions = {\n    scale: 1,\n    imageType: ImageType.png,\n    isImageMirror: false\n  };\n\n  for (var key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n\n  return captureOptions;\n}\n\nvar DEFAULT_QUALITY = 0.92;\nexport function captureImageData(video) {\n  var pictureOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n\n  var canvas = captureImageContext(video, pictureOptions);\n  var context = canvas.getContext('2d', {\n    alpha: false\n  });\n\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n\n  var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\nexport function captureImageContext(video, _ref) {\n  var _ref$scale = _ref.scale,\n      scale = _ref$scale === void 0 ? 1 : _ref$scale,\n      _ref$isImageMirror = _ref.isImageMirror,\n      isImageMirror = _ref$isImageMirror === void 0 ? false : _ref$isImageMirror;\n  var videoWidth = video.videoWidth,\n      videoHeight = video.videoHeight;\n\n  var _getImageSize = getImageSize(videoWidth, videoHeight, scale),\n      width = _getImageSize.width,\n      height = _getImageSize.height;\n\n  var canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  var context = canvas.getContext('2d', {\n    alpha: false\n  });\n\n  if (!context) {\n    throw new Error('Context is not defined');\n  }\n\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n  return canvas;\n}\nexport function captureImage(video, pictureOptions) {\n  var config = ensureCameraPictureOptions(pictureOptions);\n  var canvas = captureImageContext(video, config);\n  var imageType = config.imageType,\n      _config$quality = config.quality,\n      quality = _config$quality === void 0 ? DEFAULT_QUALITY : _config$quality;\n  return toDataURL(canvas, imageType, quality);\n}\n\nfunction getSupportedConstraints() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n\n  return null;\n}\n\nexport function getIdealConstraints(preferredCameraType, width, height) {\n  var preferredConstraints = {\n    audio: false,\n    video: {}\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  var supports = getSupportedConstraints();\n\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n\n  if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n    var facingMode = CameraTypeToFacingMode[preferredCameraType];\n\n    if (isWebKit()) {\n      var key = facingMode === 'user' ? 'exact' : 'ideal';\n      preferredConstraints.video.facingMode = _defineProperty({}, key, facingMode);\n    } else {\n      preferredConstraints.video.facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType]\n      };\n    }\n  }\n\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n\n  return preferredConstraints;\n}\n\nfunction isMediaTrackConstraints(input) {\n  return input && typeof input.video !== 'boolean';\n}\n\nexport function getPreferredStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {\n  var nextCameraType;\n  return _regeneratorRuntime.async(function getPreferredStreamDevice$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          _context.next = 3;\n          return _regeneratorRuntime.awrap(getStreamDevice(preferredCameraType, preferredWidth, preferredHeight));\n\n        case 3:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 6:\n          _context.prev = 6;\n          _context.t0 = _context[\"catch\"](0);\n\n          if (!(_context.t0 instanceof OverconstrainedError && _context.t0.constraint === 'facingMode')) {\n            _context.next = 13;\n            break;\n          }\n\n          nextCameraType = preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n          _context.next = 12;\n          return _regeneratorRuntime.awrap(getStreamDevice(nextCameraType, preferredWidth, preferredHeight));\n\n        case 12:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 13:\n          throw _context.t0;\n\n        case 14:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[0, 6]], Promise);\n}\nexport function getStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {\n  var constraints, stream;\n  return _regeneratorRuntime.async(function getStreamDevice$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          constraints = getIdealConstraints(preferredCameraType, preferredWidth, preferredHeight);\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(requestUserMediaAsync(constraints));\n\n        case 3:\n          stream = _context2.sent;\n          return _context2.abrupt(\"return\", stream);\n\n        case 5:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function isWebKit() {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\nexport function compareStreams(a, b) {\n  if (!a || !b) {\n    return false;\n  }\n\n  var settingsA = a.getTracks()[0].getSettings();\n  var settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\nexport function capture(video, settings, config) {\n  var base64 = captureImage(video, config);\n  var capturedPicture = {\n    uri: base64,\n    base64: base64,\n    width: 0,\n    height: 0\n  };\n\n  if (settings) {\n    var _settings$width = settings.width,\n        width = _settings$width === void 0 ? 0 : _settings$width,\n        _settings$height = settings.height,\n        height = _settings$height === void 0 ? 0 : _settings$height;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n\n  return capturedPicture;\n}\nexport function syncTrackCapabilities(cameraType, stream) {\n  var settings,\n      _args3 = arguments;\n  return _regeneratorRuntime.async(function syncTrackCapabilities$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          settings = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n\n          if (!(stream != null && stream.getVideoTracks)) {\n            _context3.next = 4;\n            break;\n          }\n\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(Promise.all(stream.getVideoTracks().map(function (track) {\n            return onCapabilitiesReady(cameraType, track, settings);\n          })));\n\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction onCapabilitiesReady(cameraType, track) {\n  var settings,\n      capabilities,\n      constraints,\n      clampedValues,\n      _i,\n      _clampedValues,\n      property,\n      validatedInternalConstrainedValue,\n      _args4 = arguments;\n\n  return _regeneratorRuntime.async(function onCapabilitiesReady$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          validatedInternalConstrainedValue = function _validatedInternalCon(constraintKey, settingsKey, converter) {\n            var convertedSetting = converter(settings[settingsKey]);\n            return validatedConstrainedValue({\n              constraintKey: constraintKey,\n              settingsKey: settingsKey,\n              convertedSetting: convertedSetting,\n              capabilities: capabilities,\n              settings: settings,\n              cameraType: cameraType\n            });\n          };\n\n          settings = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n          capabilities = track.getCapabilities();\n          constraints = {};\n          clampedValues = ['exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'zoom'];\n\n          for (_i = 0, _clampedValues = clampedValues; _i < _clampedValues.length; _i++) {\n            property = _clampedValues[_i];\n\n            if (capabilities[property]) {\n              constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n            }\n          }\n\n          if (capabilities.focusMode && settings.autoFocus !== undefined) {\n            constraints.focusMode = validatedInternalConstrainedValue('focusMode', 'autoFocus', CapabilityUtils.convertAutoFocusJSONToNative);\n          }\n\n          if (capabilities.torch && settings.flashMode !== undefined) {\n            constraints.torch = validatedInternalConstrainedValue('torch', 'flashMode', CapabilityUtils.convertFlashModeJSONToNative);\n          }\n\n          if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n            constraints.whiteBalanceMode = validatedInternalConstrainedValue('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n          }\n\n          _context4.prev = 9;\n          _context4.next = 12;\n          return _regeneratorRuntime.awrap(track.applyConstraints({\n            advanced: [constraints]\n          }));\n\n        case 12:\n          _context4.next = 17;\n          break;\n\n        case 14:\n          _context4.prev = 14;\n          _context4.t0 = _context4[\"catch\"](9);\n          if (__DEV__) console.warn('Failed to apply constraints', _context4.t0);\n\n        case 17:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, [[9, 14]], Promise);\n}\n\nexport function stopMediaStream(stream) {\n  if (!stream) {\n    return;\n  }\n\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach(function (track) {\n      return track.stop();\n    });\n  }\n\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach(function (track) {\n      return track.stop();\n    });\n  }\n\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\nexport function setVideoSource(video, stream) {\n  var _window$URL$createObj;\n\n  var createObjectURL = (_window$URL$createObj = window.URL.createObjectURL) != null ? _window$URL$createObj : window.webkitURL.createObjectURL;\n\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof video.mozSrcObject !== 'undefined') {\n    video.mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream);\n  }\n\n  if (!stream) {\n    var _window$URL$revokeObj, _ref2, _video$src;\n\n    var revokeObjectURL = (_window$URL$revokeObj = window.URL.revokeObjectURL) != null ? _window$URL$revokeObj : window.webkitURL.revokeObjectURL;\n    var source = (_ref2 = (_video$src = video.src) != null ? _video$src : video.srcObject) != null ? _ref2 : video.mozSrcObject;\n\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\nexport function isCapabilityAvailable(video, keyName) {\n  var stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    var _videoTrack$getCapabi;\n\n    var videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities == null ? void 0 : (_videoTrack$getCapabi = videoTrack.getCapabilities()) == null ? void 0 : _videoTrack$getCapabi[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input) {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range, value) {\n  if (!value) {\n    return;\n  }\n\n  var converted = convertRange(value, [range.min, range.max]);\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value, r2) {\n  var r1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 1];\n  return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue(props) {\n  var constraintKey = props.constraintKey,\n      settingsKey = props.settingsKey,\n      convertedSetting = props.convertedSetting,\n      capabilities = props.capabilities,\n      settings = props.settings,\n      cameraType = props.cameraType;\n  var setting = settings[settingsKey];\n\n  if (Array.isArray(capabilities[constraintKey]) && convertedSetting && !capabilities[constraintKey].includes(convertedSetting)) {\n    if (__DEV__) {\n      console.warn(\" { \" + settingsKey + \": \\\"\" + setting + \"\\\" } (converted to \\\"\" + convertedSetting + \"\\\" in the browser) is not supported for camera type \\\"\" + cameraType + \"\\\" in your browser. Using the default value instead.\");\n    }\n\n    return undefined;\n  }\n\n  return convertedSetting;\n}","map":{"version":3,"mappings":"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","names":["invariant","CameraType","ImageType","CapabilityUtils","CameraTypeToFacingMode","ImageTypeFormat","MinimumConstraints","requestUserMediaAsync","getImageSize","videoWidth","videoHeight","scale","width","ratio","height","toDataURL","canvas","imageType","quality","Object","values","includes","join","format","jpg","hasValidConstraints","preferredCameraType","undefined","ensureCameraPictureOptions","config","captureOptions","png","isImageMirror","key","DEFAULT_QUALITY","captureImageData","video","pictureOptions","readyState","HAVE_ENOUGH_DATA","captureImageContext","context","getContext","alpha","imageData","getImageData","document","createElement","Error","setTransform","drawImage","captureImage","getSupportedConstraints","navigator","mediaDevices","getIdealConstraints","preferredConstraints","audio","supports","facingMode","isWebKit","ideal","isMediaTrackConstraints","input","getPreferredStreamDevice","preferredWidth","preferredHeight","getStreamDevice","OverconstrainedError","constraint","nextCameraType","back","front","constraints","stream","test","userAgent","compareStreams","a","b","settingsA","getTracks","getSettings","settingsB","deviceId","capture","settings","base64","capturedPicture","uri","exif","onPictureSaved","syncTrackCapabilities","cameraType","getVideoTracks","Promise","all","map","track","onCapabilitiesReady","validatedInternalConstrainedValue","constraintKey","settingsKey","converter","convertedSetting","validatedConstrainedValue","capabilities","getCapabilities","clampedValues","property","convertNormalizedSetting","focusMode","autoFocus","convertAutoFocusJSONToNative","torch","flashMode","convertFlashModeJSONToNative","whiteBalanceMode","whiteBalance","convertWhiteBalanceJSONToNative","applyConstraints","advanced","__DEV__","console","warn","stopMediaStream","getAudioTracks","forEach","stop","isMediaStreamTrack","setVideoSource","createObjectURL","window","URL","webkitURL","srcObject","mozSrcObject","src","revokeObjectURL","source","isCapabilityAvailable","keyName","MediaStream","videoTrack","range","value","converted","convertRange","min","max","Math","r2","r1","props","setting","Array","isArray"],"sourceRoot":"","sources":["D:/Users/georg/Desktop/MAD/SpaceBook/node_modules/expo-camera/build/WebCameraUtils.js"],"sourcesContent":["/* eslint-env browser */\nimport invariant from 'invariant';\nimport { CameraType, ImageType, } from './Camera.types';\nimport * as CapabilityUtils from './WebCapabilityUtils';\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from './WebConstants';\nimport { requestUserMediaAsync } from './WebUserMediaManager';\nexport function getImageSize(videoWidth, videoHeight, scale) {\n    const width = videoWidth * scale;\n    const ratio = videoWidth / width;\n    const height = videoHeight / ratio;\n    return {\n        width,\n        height,\n    };\n}\nexport function toDataURL(canvas, imageType, quality) {\n    invariant(Object.values(ImageType).includes(imageType), `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${Object.values(ImageType).join(', ')}`);\n    const format = ImageTypeFormat[imageType];\n    if (imageType === ImageType.jpg) {\n        invariant(quality <= 1 && quality >= 0, `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`);\n        return canvas.toDataURL(format, quality);\n    }\n    else {\n        return canvas.toDataURL(format);\n    }\n}\nexport function hasValidConstraints(preferredCameraType, width, height) {\n    return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\nfunction ensureCameraPictureOptions(config) {\n    const captureOptions = {\n        scale: 1,\n        imageType: ImageType.png,\n        isImageMirror: false,\n    };\n    for (const key in config) {\n        if (key in config && config[key] !== undefined && key in captureOptions) {\n            captureOptions[key] = config[key];\n        }\n    }\n    return captureOptions;\n}\nconst DEFAULT_QUALITY = 0.92;\nexport function captureImageData(video, pictureOptions = {}) {\n    if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n        return null;\n    }\n    const canvas = captureImageContext(video, pictureOptions);\n    const context = canvas.getContext('2d', { alpha: false });\n    if (!context || !canvas.width || !canvas.height) {\n        return null;\n    }\n    const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n    return imageData;\n}\nexport function captureImageContext(video, { scale = 1, isImageMirror = false }) {\n    const { videoWidth, videoHeight } = video;\n    const { width, height } = getImageSize(videoWidth, videoHeight, scale);\n    // Build the canvas size and draw the camera image to the context from video\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext('2d', { alpha: false });\n    if (!context) {\n        // Should never be called\n        throw new Error('Context is not defined');\n    }\n    // sharp image details\n    // context.imageSmoothingEnabled = false;\n    // Flip horizontally (as css transform: rotateY(180deg))\n    if (isImageMirror) {\n        context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n    }\n    context.drawImage(video, 0, 0, width, height);\n    return canvas;\n}\nexport function captureImage(video, pictureOptions) {\n    const config = ensureCameraPictureOptions(pictureOptions);\n    const canvas = captureImageContext(video, config);\n    const { imageType, quality = DEFAULT_QUALITY } = config;\n    return toDataURL(canvas, imageType, quality);\n}\nfunction getSupportedConstraints() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n        return navigator.mediaDevices.getSupportedConstraints();\n    }\n    return null;\n}\nexport function getIdealConstraints(preferredCameraType, width, height) {\n    const preferredConstraints = {\n        audio: false,\n        video: {},\n    };\n    if (hasValidConstraints(preferredCameraType, width, height)) {\n        return MinimumConstraints;\n    }\n    const supports = getSupportedConstraints();\n    // TODO(Bacon): Test this\n    if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n        return MinimumConstraints;\n    }\n    if (preferredCameraType && Object.values(CameraType).includes(preferredCameraType)) {\n        const facingMode = CameraTypeToFacingMode[preferredCameraType];\n        if (isWebKit()) {\n            const key = facingMode === 'user' ? 'exact' : 'ideal';\n            preferredConstraints.video.facingMode = {\n                [key]: facingMode,\n            };\n        }\n        else {\n            preferredConstraints.video.facingMode = {\n                ideal: CameraTypeToFacingMode[preferredCameraType],\n            };\n        }\n    }\n    if (isMediaTrackConstraints(preferredConstraints.video)) {\n        preferredConstraints.video.width = width;\n        preferredConstraints.video.height = height;\n    }\n    return preferredConstraints;\n}\nfunction isMediaTrackConstraints(input) {\n    return input && typeof input.video !== 'boolean';\n}\n/**\n * Invoke getStreamDevice a second time with the opposing camera type if the preferred type cannot be retrieved.\n *\n * @param preferredCameraType\n * @param preferredWidth\n * @param preferredHeight\n */\nexport async function getPreferredStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {\n    try {\n        return await getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n    }\n    catch (error) {\n        // A hack on desktop browsers to ensure any camera is used.\n        // eslint-disable-next-line no-undef\n        if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n            const nextCameraType = preferredCameraType === CameraType.back ? CameraType.front : CameraType.back;\n            return await getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n        }\n        throw error;\n    }\n}\nexport async function getStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {\n    const constraints = getIdealConstraints(preferredCameraType, preferredWidth, preferredHeight);\n    const stream = await requestUserMediaAsync(constraints);\n    return stream;\n}\nexport function isWebKit() {\n    return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\nexport function compareStreams(a, b) {\n    if (!a || !b) {\n        return false;\n    }\n    const settingsA = a.getTracks()[0].getSettings();\n    const settingsB = b.getTracks()[0].getSettings();\n    return settingsA.deviceId === settingsB.deviceId;\n}\nexport function capture(video, settings, config) {\n    const base64 = captureImage(video, config);\n    const capturedPicture = {\n        uri: base64,\n        base64,\n        width: 0,\n        height: 0,\n    };\n    if (settings) {\n        const { width = 0, height = 0 } = settings;\n        capturedPicture.width = width;\n        capturedPicture.height = height;\n        capturedPicture.exif = settings;\n    }\n    if (config.onPictureSaved) {\n        config.onPictureSaved(capturedPicture);\n    }\n    return capturedPicture;\n}\nexport async function syncTrackCapabilities(cameraType, stream, settings = {}) {\n    if (stream?.getVideoTracks) {\n        await Promise.all(stream.getVideoTracks().map((track) => onCapabilitiesReady(cameraType, track, settings)));\n    }\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\nasync function onCapabilitiesReady(cameraType, track, settings = {}) {\n    const capabilities = track.getCapabilities();\n    // Create an empty object because if you set a constraint that isn't available an error will be thrown.\n    const constraints = {};\n    // TODO(Bacon): Add `pointsOfInterest` support\n    const clampedValues = [\n        'exposureCompensation',\n        'colorTemperature',\n        'iso',\n        'brightness',\n        'contrast',\n        'saturation',\n        'sharpness',\n        'focusDistance',\n        'zoom',\n    ];\n    for (const property of clampedValues) {\n        if (capabilities[property]) {\n            constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n        }\n    }\n    function validatedInternalConstrainedValue(constraintKey, settingsKey, converter) {\n        const convertedSetting = converter(settings[settingsKey]);\n        return validatedConstrainedValue({\n            constraintKey,\n            settingsKey,\n            convertedSetting,\n            capabilities,\n            settings,\n            cameraType,\n        });\n    }\n    if (capabilities.focusMode && settings.autoFocus !== undefined) {\n        constraints.focusMode = validatedInternalConstrainedValue('focusMode', 'autoFocus', CapabilityUtils.convertAutoFocusJSONToNative);\n    }\n    if (capabilities.torch && settings.flashMode !== undefined) {\n        constraints.torch = validatedInternalConstrainedValue('torch', 'flashMode', CapabilityUtils.convertFlashModeJSONToNative);\n    }\n    if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n        constraints.whiteBalanceMode = validatedInternalConstrainedValue('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n    }\n    try {\n        await track.applyConstraints({ advanced: [constraints] });\n    }\n    catch (error) {\n        if (__DEV__)\n            console.warn('Failed to apply constraints', error);\n    }\n}\nexport function stopMediaStream(stream) {\n    if (!stream) {\n        return;\n    }\n    if (stream.getAudioTracks) {\n        stream.getAudioTracks().forEach((track) => track.stop());\n    }\n    if (stream.getVideoTracks) {\n        stream.getVideoTracks().forEach((track) => track.stop());\n    }\n    if (isMediaStreamTrack(stream)) {\n        stream.stop();\n    }\n}\nexport function setVideoSource(video, stream) {\n    const createObjectURL = window.URL.createObjectURL ?? window.webkitURL.createObjectURL;\n    if (typeof video.srcObject !== 'undefined') {\n        video.srcObject = stream;\n    }\n    else if (typeof video.mozSrcObject !== 'undefined') {\n        video.mozSrcObject = stream;\n    }\n    else if (stream && createObjectURL) {\n        video.src = createObjectURL(stream);\n    }\n    if (!stream) {\n        const revokeObjectURL = window.URL.revokeObjectURL ?? window.webkitURL.revokeObjectURL;\n        const source = video.src ?? video.srcObject ?? video.mozSrcObject;\n        if (revokeObjectURL && typeof source === 'string') {\n            revokeObjectURL(source);\n        }\n    }\n}\nexport function isCapabilityAvailable(video, keyName) {\n    const stream = video.srcObject;\n    if (stream instanceof MediaStream) {\n        const videoTrack = stream.getVideoTracks()[0];\n        return videoTrack.getCapabilities?.()?.[keyName];\n    }\n    return false;\n}\nfunction isMediaStreamTrack(input) {\n    return typeof input.stop === 'function';\n}\nfunction convertNormalizedSetting(range, value) {\n    if (!value) {\n        return;\n    }\n    // convert the normalized incoming setting to the native camera zoom range\n    const converted = convertRange(value, [range.min, range.max]);\n    // clamp value so we don't get an error\n    return Math.min(range.max, Math.max(range.min, converted));\n}\nfunction convertRange(value, r2, r1 = [0, 1]) {\n    return ((value - r1[0]) * (r2[1] - r2[0])) / (r1[1] - r1[0]) + r2[0];\n}\nfunction validatedConstrainedValue(props) {\n    const { constraintKey, settingsKey, convertedSetting, capabilities, settings, cameraType } = props;\n    const setting = settings[settingsKey];\n    if (Array.isArray(capabilities[constraintKey]) &&\n        convertedSetting &&\n        !capabilities[constraintKey].includes(convertedSetting)) {\n        if (__DEV__) {\n            // Only warn in dev mode.\n            console.warn(` { ${settingsKey}: \"${setting}\" } (converted to \"${convertedSetting}\" in the browser) is not supported for camera type \"${cameraType}\" in your browser. Using the default value instead.`);\n        }\n        return undefined;\n    }\n    return convertedSetting;\n}\n//# sourceMappingURL=WebCameraUtils.js.map"]},"metadata":{},"sourceType":"module"}