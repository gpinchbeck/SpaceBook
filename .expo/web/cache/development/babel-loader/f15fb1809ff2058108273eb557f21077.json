{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { createPermissionHook, Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport { PermissionStatus } from \"./Camera.types\";\nimport ExponentCamera from \"./ExponentCamera\";\nimport CameraManager from \"./ExponentCameraManager\";\nimport { ConversionTables, ensureNativeProps } from \"./utils/props\";\nvar EventThrottleMs = 500;\nvar _PICTURE_SAVED_CALLBACKS = {};\nvar _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options) {\n  var pictureOptions = !options || typeof options !== 'object' ? {} : options;\n\n  if (!pictureOptions.quality) {\n    pictureOptions.quality = 1;\n  }\n\n  if (pictureOptions.onPictureSaved) {\n    var id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = pictureOptions.onPictureSaved;\n    pictureOptions.id = id;\n    pictureOptions.fastMode = true;\n  }\n\n  return pictureOptions;\n}\n\nfunction ensureRecordingOptions(options) {\n  var recordingOptions = options || {};\n\n  if (!recordingOptions || typeof recordingOptions !== 'object') {\n    recordingOptions = {};\n  } else if (typeof recordingOptions.quality === 'string') {\n    recordingOptions.quality = Camera.Constants.VideoQuality[recordingOptions.quality];\n  }\n\n  return recordingOptions;\n}\n\nfunction _onPictureSaved(_ref) {\n  var nativeEvent = _ref.nativeEvent;\n  var id = nativeEvent.id,\n      data = nativeEvent.data;\n  var callback = _PICTURE_SAVED_CALLBACKS[id];\n\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nvar Camera = function (_React$Component) {\n  _inherits(Camera, _React$Component);\n\n  var _super = _createSuper(Camera);\n\n  function Camera() {\n    var _this;\n\n    _classCallCheck(this, Camera);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._lastEvents = {};\n    _this._lastEventsTimes = {};\n\n    _this._onCameraReady = function () {\n      if (_this.props.onCameraReady) {\n        _this.props.onCameraReady();\n      }\n    };\n\n    _this._onMountError = function (_ref2) {\n      var nativeEvent = _ref2.nativeEvent;\n\n      if (_this.props.onMountError) {\n        _this.props.onMountError(nativeEvent);\n      }\n    };\n\n    _this._onObjectDetected = function (callback) {\n      return function (_ref3) {\n        var nativeEvent = _ref3.nativeEvent;\n        var type = nativeEvent.type;\n\n        if (_this._lastEvents[type] && _this._lastEventsTimes[type] && JSON.stringify(nativeEvent) === _this._lastEvents[type] && new Date().getTime() - _this._lastEventsTimes[type].getTime() < EventThrottleMs) {\n          return;\n        }\n\n        if (callback) {\n          callback(nativeEvent);\n          _this._lastEventsTimes[type] = new Date();\n          _this._lastEvents[type] = JSON.stringify(nativeEvent);\n        }\n      };\n    };\n\n    _this._setReference = function (ref) {\n      if (ref) {\n        _this._cameraRef = ref;\n\n        if (Platform.OS === 'web') {\n          _this._cameraHandle = ref;\n        } else {\n          _this._cameraHandle = findNodeHandle(ref);\n        }\n      } else {\n        _this._cameraRef = null;\n        _this._cameraHandle = null;\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(Camera, [{\n    key: \"takePictureAsync\",\n    value: function takePictureAsync(options) {\n      var pictureOptions;\n      return _regeneratorRuntime.async(function takePictureAsync$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              pictureOptions = ensurePictureOptions(options);\n              _context.next = 3;\n              return _regeneratorRuntime.awrap(CameraManager.takePicture(pictureOptions, this._cameraHandle));\n\n            case 3:\n              return _context.abrupt(\"return\", _context.sent);\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getSupportedRatiosAsync\",\n    value: function getSupportedRatiosAsync() {\n      return _regeneratorRuntime.async(function getSupportedRatiosAsync$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (CameraManager.getSupportedRatios) {\n                _context2.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Camera', 'getSupportedRatiosAsync');\n\n            case 2:\n              _context2.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.getSupportedRatios(this._cameraHandle));\n\n            case 4:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"getAvailablePictureSizesAsync\",\n    value: function getAvailablePictureSizesAsync(ratio) {\n      return _regeneratorRuntime.async(function getAvailablePictureSizesAsync$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (CameraManager.getAvailablePictureSizes) {\n                _context3.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Camera', 'getAvailablePictureSizesAsync');\n\n            case 2:\n              _context3.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.getAvailablePictureSizes(ratio, this._cameraHandle));\n\n            case 4:\n              return _context3.abrupt(\"return\", _context3.sent);\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"recordAsync\",\n    value: function recordAsync(options) {\n      var recordingOptions;\n      return _regeneratorRuntime.async(function recordAsync$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (CameraManager.record) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Camera', 'recordAsync');\n\n            case 2:\n              recordingOptions = ensureRecordingOptions(options);\n              _context4.next = 5;\n              return _regeneratorRuntime.awrap(CameraManager.record(recordingOptions, this._cameraHandle));\n\n            case 5:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 6:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"stopRecording\",\n    value: function stopRecording() {\n      if (!CameraManager.stopRecording) {\n        throw new UnavailabilityError('Camera', 'stopRecording');\n      }\n\n      CameraManager.stopRecording(this._cameraHandle);\n    }\n  }, {\n    key: \"pausePreview\",\n    value: function pausePreview() {\n      if (!CameraManager.pausePreview) {\n        throw new UnavailabilityError('Camera', 'pausePreview');\n      }\n\n      CameraManager.pausePreview(this._cameraHandle);\n    }\n  }, {\n    key: \"resumePreview\",\n    value: function resumePreview() {\n      if (!CameraManager.resumePreview) {\n        throw new UnavailabilityError('Camera', 'resumePreview');\n      }\n\n      CameraManager.resumePreview(this._cameraHandle);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var nativeProps = ensureNativeProps(this.props);\n      var onBarCodeScanned = this.props.onBarCodeScanned ? this._onObjectDetected(this.props.onBarCodeScanned) : undefined;\n\n      var onFacesDetected = this._onObjectDetected(this.props.onFacesDetected);\n\n      return React.createElement(ExponentCamera, _objectSpread(_objectSpread({}, nativeProps), {}, {\n        ref: this._setReference,\n        onCameraReady: this._onCameraReady,\n        onMountError: this._onMountError,\n        onBarCodeScanned: onBarCodeScanned,\n        onFacesDetected: onFacesDetected,\n        onPictureSaved: _onPictureSaved\n      }));\n    }\n  }], [{\n    key: \"isAvailableAsync\",\n    value: function isAvailableAsync() {\n      return _regeneratorRuntime.async(function isAvailableAsync$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (CameraManager.isAvailableAsync) {\n                _context5.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n\n            case 2:\n              _context5.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.isAvailableAsync());\n\n            case 4:\n              return _context5.abrupt(\"return\", _context5.sent);\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getAvailableCameraTypesAsync\",\n    value: function getAvailableCameraTypesAsync() {\n      return _regeneratorRuntime.async(function getAvailableCameraTypesAsync$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (CameraManager.getAvailableCameraTypesAsync) {\n                _context6.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('expo-camera', 'getAvailableCameraTypesAsync');\n\n            case 2:\n              _context6.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.getAvailableCameraTypesAsync());\n\n            case 4:\n              return _context6.abrupt(\"return\", _context6.sent);\n\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getAvailableVideoCodecsAsync\",\n    value: function getAvailableVideoCodecsAsync() {\n      return _regeneratorRuntime.async(function getAvailableVideoCodecsAsync$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (CameraManager.getAvailableVideoCodecsAsync) {\n                _context7.next = 2;\n                break;\n              }\n\n              throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n\n            case 2:\n              _context7.next = 4;\n              return _regeneratorRuntime.awrap(CameraManager.getAvailableVideoCodecsAsync());\n\n            case 4:\n              return _context7.abrupt(\"return\", _context7.sent);\n\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getPermissionsAsync\",\n    value: function getPermissionsAsync() {\n      return _regeneratorRuntime.async(function getPermissionsAsync$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              console.warn(\"\\\"getPermissionsAsync()\\\" is now deprecated. Please use \\\"getCameraPermissionsAsync()\\\" or \\\"getMicrophonePermissionsAsync()\\\" instead.\");\n              return _context8.abrupt(\"return\", CameraManager.getPermissionsAsync());\n\n            case 2:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"requestPermissionsAsync\",\n    value: function requestPermissionsAsync() {\n      return _regeneratorRuntime.async(function requestPermissionsAsync$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              console.warn(\"\\\"requestPermissionsAsync()\\\" is now deprecated. Please use \\\"requestCameraPermissionsAsync()\\\" or \\\"requestMicrophonePermissionsAsync()\\\" instead.\");\n              return _context9.abrupt(\"return\", CameraManager.requestPermissionsAsync());\n\n            case 2:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getCameraPermissionsAsync\",\n    value: function getCameraPermissionsAsync() {\n      return _regeneratorRuntime.async(function getCameraPermissionsAsync$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", CameraManager.getCameraPermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"requestCameraPermissionsAsync\",\n    value: function requestCameraPermissionsAsync() {\n      return _regeneratorRuntime.async(function requestCameraPermissionsAsync$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              return _context11.abrupt(\"return\", CameraManager.requestCameraPermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"getMicrophonePermissionsAsync\",\n    value: function getMicrophonePermissionsAsync() {\n      return _regeneratorRuntime.async(function getMicrophonePermissionsAsync$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              return _context12.abrupt(\"return\", CameraManager.getMicrophonePermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"requestMicrophonePermissionsAsync\",\n    value: function requestMicrophonePermissionsAsync() {\n      return _regeneratorRuntime.async(function requestMicrophonePermissionsAsync$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              return _context13.abrupt(\"return\", CameraManager.requestMicrophonePermissionsAsync());\n\n            case 1:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }]);\n\n  return Camera;\n}(React.Component);\n\nCamera.Constants = {\n  Type: CameraManager.Type,\n  FlashMode: CameraManager.FlashMode,\n  AutoFocus: CameraManager.AutoFocus,\n  WhiteBalance: CameraManager.WhiteBalance,\n  VideoQuality: CameraManager.VideoQuality,\n  VideoStabilization: CameraManager.VideoStabilization || {},\n  VideoCodec: CameraManager.VideoCodec\n};\nCamera.ConversionTables = ConversionTables;\nCamera.defaultProps = {\n  zoom: 0,\n  ratio: '4:3',\n  focusDepth: 0,\n  faceDetectorSettings: {},\n  type: CameraManager.Type.back,\n  autoFocus: CameraManager.AutoFocus.on,\n  flashMode: CameraManager.FlashMode.off,\n  whiteBalance: CameraManager.WhiteBalance.auto\n};\nCamera.useCameraPermissions = createPermissionHook({\n  getMethod: Camera.getCameraPermissionsAsync,\n  requestMethod: Camera.requestCameraPermissionsAsync\n});\nCamera.useMicrophonePermissions = createPermissionHook({\n  getMethod: Camera.getMicrophonePermissionsAsync,\n  requestMethod: Camera.requestMicrophonePermissionsAsync\n});\nexport { Camera as default };\nvar Constants = Camera.Constants,\n    getPermissionsAsync = Camera.getPermissionsAsync,\n    requestPermissionsAsync = Camera.requestPermissionsAsync,\n    getCameraPermissionsAsync = Camera.getCameraPermissionsAsync,\n    requestCameraPermissionsAsync = Camera.requestCameraPermissionsAsync,\n    getMicrophonePermissionsAsync = Camera.getMicrophonePermissionsAsync,\n    requestMicrophonePermissionsAsync = Camera.requestMicrophonePermissionsAsync;\nexport { Constants, getPermissionsAsync, requestPermissionsAsync, getCameraPermissionsAsync, requestCameraPermissionsAsync, getMicrophonePermissionsAsync, requestMicrophonePermissionsAsync };\nexport { PermissionStatus };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;AAAA,SAASA,oBAAT,EAA+BC,QAA/B,EAAyCC,mBAAzC,QAAoE,mBAApE;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;;AAEA,SAASC,gBAAT;AACA,OAAOC,cAAP;AACA,OAAOC,aAAP;AACA,SAASC,gBAAT,EAA2BC,iBAA3B;AACA,IAAMC,eAAe,GAAG,GAAxB;AACA,IAAMC,wBAAwB,GAAG,EAAjC;AACA,IAAIC,kBAAkB,GAAG,CAAzB;;AACA,SAASC,oBAAT,CAA8BC,OAA9B,EAAuC;AACnC,MAAMC,cAAc,GAAG,CAACD,OAAD,IAAY,OAAOA,OAAP,KAAmB,QAA/B,GAA0C,EAA1C,GAA+CA,OAAtE;;AACA,MAAI,CAACC,cAAc,CAACC,OAApB,EAA6B;AACzBD,kBAAc,CAACC,OAAf,GAAyB,CAAzB;AACH;;AACD,MAAID,cAAc,CAACE,cAAnB,EAAmC;AAC/B,QAAMC,EAAE,GAAGN,kBAAkB,EAA7B;AACAD,4BAAwB,CAACO,EAAD,CAAxB,GAA+BH,cAAc,CAACE,cAA9C;AACAF,kBAAc,CAACG,EAAf,GAAoBA,EAApB;AACAH,kBAAc,CAACI,QAAf,GAA0B,IAA1B;AACH;;AACD,SAAOJ,cAAP;AACH;;AACD,SAASK,sBAAT,CAAgCN,OAAhC,EAAyC;AACrC,MAAIO,gBAAgB,GAAGP,OAAO,IAAI,EAAlC;;AACA,MAAI,CAACO,gBAAD,IAAqB,OAAOA,gBAAP,KAA4B,QAArD,EAA+D;AAC3DA,oBAAgB,GAAG,EAAnB;AACH,GAFD,MAGK,IAAI,OAAOA,gBAAgB,CAACL,OAAxB,KAAoC,QAAxC,EAAkD;AACnDK,oBAAgB,CAACL,OAAjB,GAA2BM,MAAM,CAACC,SAAP,CAAiBC,YAAjB,CAA8BH,gBAAgB,CAACL,OAA/C,CAA3B;AACH;;AACD,SAAOK,gBAAP;AACH;;AACD,SAASI,eAAT,OAA2C;AAAA,MAAhBC,WAAgB,QAAhBA,WAAgB;AACvC,MAAQR,EAAR,GAAqBQ,WAArB,CAAQR,EAAR;AAAA,MAAYS,IAAZ,GAAqBD,WAArB,CAAYC,IAAZ;AACA,MAAMC,QAAQ,GAAGjB,wBAAwB,CAACO,EAAD,CAAzC;;AACA,MAAIU,QAAJ,EAAc;AACVA,YAAQ,CAACD,IAAD,CAAR;AACA,WAAOhB,wBAAwB,CAACO,EAAD,CAA/B;AACH;AACJ;;IACoBI,M;;;;;;;;;;;;;;;UAgGjBO,W,GAAc,E;UACdC,gB,GAAmB,E;;UA0CnBC,c,GAAiB,YAAM;AACnB,UAAI,MAAKC,KAAL,CAAWC,aAAf,EAA8B;AAC1B,cAAKD,KAAL,CAAWC,aAAX;AACH;AACJ,K;;UACDC,a,GAAgB,iBAAqB;AAAA,UAAlBR,WAAkB,SAAlBA,WAAkB;;AACjC,UAAI,MAAKM,KAAL,CAAWG,YAAf,EAA6B;AACzB,cAAKH,KAAL,CAAWG,YAAX,CAAwBT,WAAxB;AACH;AACJ,K;;UACDU,iB,GAAoB,UAACR,QAAD;AAAA,aAAc,iBAAqB;AAAA,YAAlBF,WAAkB,SAAlBA,WAAkB;AACnD,YAAQW,IAAR,GAAiBX,WAAjB,CAAQW,IAAR;;AACA,YAAI,MAAKR,WAAL,CAAiBQ,IAAjB,KACA,MAAKP,gBAAL,CAAsBO,IAAtB,CADA,IAEAC,IAAI,CAACC,SAAL,CAAeb,WAAf,MAAgC,MAAKG,WAAL,CAAiBQ,IAAjB,CAFhC,IAGA,IAAIG,IAAJ,GAAWC,OAAX,KAAuB,MAAKX,gBAAL,CAAsBO,IAAtB,EAA4BI,OAA5B,EAAvB,GAA+D/B,eAHnE,EAGoF;AAChF;AACH;;AACD,YAAIkB,QAAJ,EAAc;AACVA,kBAAQ,CAACF,WAAD,CAAR;AACA,gBAAKI,gBAAL,CAAsBO,IAAtB,IAA8B,IAAIG,IAAJ,EAA9B;AACA,gBAAKX,WAAL,CAAiBQ,IAAjB,IAAyBC,IAAI,CAACC,SAAL,CAAeb,WAAf,CAAzB;AACH;AACJ,OAbmB;AAAA,K;;UAcpBgB,a,GAAgB,UAACC,GAAD,EAAS;AACrB,UAAIA,GAAJ,EAAS;AACL,cAAKC,UAAL,GAAkBD,GAAlB;;AAEA,YAAIzC,QAAQ,CAAC2C,EAAT,KAAgB,KAApB,EAA2B;AACvB,gBAAKC,aAAL,GAAqBH,GAArB;AACH,SAFD,MAGK;AACD,gBAAKG,aAAL,GAAqBC,cAAc,CAACJ,GAAD,CAAnC;AACH;AACJ,OATD,MAUK;AACD,cAAKC,UAAL,GAAkB,IAAlB;AACA,cAAKE,aAAL,GAAqB,IAArB;AACH;AACJ,K;;;;;;;WAhFD,0BAAuBhC,OAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AACUC,4BADV,GAC2BF,oBAAoB,CAACC,OAAD,CAD/C;AAAA;AAAA,+CAEiBP,aAAa,CAACyC,WAAd,CAA0BjC,cAA1B,EAA0C,KAAK+B,aAA/C,CAFjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAIA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACSvC,aAAa,CAAC0C,kBADvB;AAAA;AAAA;AAAA;;AAAA,oBAEc,IAAI9C,mBAAJ,CAAwB,QAAxB,EAAkC,yBAAlC,CAFd;;AAAA;AAAA;AAAA,+CAIiBI,aAAa,CAAC0C,kBAAd,CAAiC,KAAKH,aAAtC,CAJjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAMA,uCAAoCI,KAApC;AAAA;AAAA;AAAA;AAAA;AAAA,kBACS3C,aAAa,CAAC4C,wBADvB;AAAA;AAAA;AAAA;;AAAA,oBAEc,IAAIhD,mBAAJ,CAAwB,QAAxB,EAAkC,+BAAlC,CAFd;;AAAA;AAAA;AAAA,+CAIiBI,aAAa,CAAC4C,wBAAd,CAAuCD,KAAvC,EAA8C,KAAKJ,aAAnD,CAJjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAMA,qBAAkBhC,OAAlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACSP,aAAa,CAAC6C,MADvB;AAAA;AAAA;AAAA;;AAAA,oBAEc,IAAIjD,mBAAJ,CAAwB,QAAxB,EAAkC,aAAlC,CAFd;;AAAA;AAIUkB,8BAJV,GAI6BD,sBAAsB,CAACN,OAAD,CAJnD;AAAA;AAAA,+CAKiBP,aAAa,CAAC6C,MAAd,CAAqB/B,gBAArB,EAAuC,KAAKyB,aAA5C,CALjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAOA,yBAAgB;AACZ,UAAI,CAACvC,aAAa,CAAC8C,aAAnB,EAAkC;AAC9B,cAAM,IAAIlD,mBAAJ,CAAwB,QAAxB,EAAkC,eAAlC,CAAN;AACH;;AACDI,mBAAa,CAAC8C,aAAd,CAA4B,KAAKP,aAAjC;AACH;;;WACD,wBAAe;AACX,UAAI,CAACvC,aAAa,CAAC+C,YAAnB,EAAiC;AAC7B,cAAM,IAAInD,mBAAJ,CAAwB,QAAxB,EAAkC,cAAlC,CAAN;AACH;;AACDI,mBAAa,CAAC+C,YAAd,CAA2B,KAAKR,aAAhC;AACH;;;WACD,yBAAgB;AACZ,UAAI,CAACvC,aAAa,CAACgD,aAAnB,EAAkC;AAC9B,cAAM,IAAIpD,mBAAJ,CAAwB,QAAxB,EAAkC,eAAlC,CAAN;AACH;;AACDI,mBAAa,CAACgD,aAAd,CAA4B,KAAKT,aAAjC;AACH;;;WAyCD,kBAAS;AACL,UAAMU,WAAW,GAAG/C,iBAAiB,CAAC,KAAKuB,KAAN,CAArC;AACA,UAAMyB,gBAAgB,GAAG,KAAKzB,KAAL,CAAWyB,gBAAX,GACnB,KAAKrB,iBAAL,CAAuB,KAAKJ,KAAL,CAAWyB,gBAAlC,CADmB,GAEnBC,SAFN;;AAGA,UAAMC,eAAe,GAAG,KAAKvB,iBAAL,CAAuB,KAAKJ,KAAL,CAAW2B,eAAlC,CAAxB;;AACA,aAAQvD,KAAK,CAACwD,aAAN,CAAoBtD,cAApB,kCAAyCkD,WAAzC;AAAsDb,WAAG,EAAE,KAAKD,aAAhE;AAA+ET,qBAAa,EAAE,KAAKF,cAAnG;AAAmHI,oBAAY,EAAE,KAAKD,aAAtI;AAAqJuB,wBAAgB,EAAEA,gBAAvK;AAAyLE,uBAAe,EAAEA,eAA1M;AAA2N1C,sBAAc,EAAEQ;AAA3O,SAAR;AACH;;;WAzLD;AAAA;AAAA;AAAA;AAAA;AAAA,kBACSlB,aAAa,CAACsD,gBADvB;AAAA;AAAA;AAAA;;AAAA,oBAEc,IAAI1D,mBAAJ,CAAwB,aAAxB,EAAuC,kBAAvC,CAFd;;AAAA;AAAA;AAAA,+CAIiBI,aAAa,CAACsD,gBAAd,EAJjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAMA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACStD,aAAa,CAACuD,4BADvB;AAAA;AAAA;AAAA;;AAAA,oBAEc,IAAI3D,mBAAJ,CAAwB,aAAxB,EAAuC,8BAAvC,CAFd;;AAAA;AAAA;AAAA,+CAIiBI,aAAa,CAACuD,4BAAd,EAJjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAMA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACSvD,aAAa,CAACwD,4BADvB;AAAA;AAAA;AAAA;;AAAA,oBAEc,IAAI5D,mBAAJ,CAAwB,QAAxB,EAAkC,8BAAlC,CAFd;;AAAA;AAAA;AAAA,+CAIiBI,aAAa,CAACwD,4BAAd,EAJjB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WA8BA;AAAA;AAAA;AAAA;AAAA;AACIC,qBAAO,CAACC,IAAR;AADJ,gDAEW1D,aAAa,CAAC2D,mBAAd,EAFX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAOA;AAAA;AAAA;AAAA;AAAA;AACIF,qBAAO,CAACC,IAAR;AADJ,gDAEW1D,aAAa,CAAC4D,uBAAd,EAFX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAIA;AAAA;AAAA;AAAA;AAAA;AAAA,iDACW5D,aAAa,CAAC6D,yBAAd,EADX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAGA;AAAA;AAAA;AAAA;AAAA;AAAA,iDACW7D,aAAa,CAAC8D,6BAAd,EADX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAiBA;AAAA;AAAA;AAAA;AAAA;AAAA,iDACW9D,aAAa,CAAC+D,6BAAd,EADX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAGA;AAAA;AAAA;AAAA;AAAA;AAAA,iDACW/D,aAAa,CAACgE,iCAAd,EADX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;EA7EgCnE,KAAK,CAACoE,S;;AAArBlD,M,CAmBVC,S,GAAY;AACfkD,MAAI,EAAElE,aAAa,CAACkE,IADL;AAEfC,WAAS,EAAEnE,aAAa,CAACmE,SAFV;AAGfC,WAAS,EAAEpE,aAAa,CAACoE,SAHV;AAIfC,cAAY,EAAErE,aAAa,CAACqE,YAJb;AAKfpD,cAAY,EAAEjB,aAAa,CAACiB,YALb;AAMfqD,oBAAkB,EAAEtE,aAAa,CAACsE,kBAAd,IAAoC,EANzC;AAOfC,YAAU,EAAEvE,aAAa,CAACuE;AAPX,C;AAnBFxD,M,CA6BVd,gB,GAAmBA,gB;AA7BTc,M,CA8BVyD,Y,GAAe;AAClBC,MAAI,EAAE,CADY;AAElB9B,OAAK,EAAE,KAFW;AAGlB+B,YAAU,EAAE,CAHM;AAIlBC,sBAAoB,EAAE,EAJJ;AAKlB7C,MAAI,EAAE9B,aAAa,CAACkE,IAAd,CAAmBU,IALP;AAMlBC,WAAS,EAAE7E,aAAa,CAACoE,SAAd,CAAwBU,EANjB;AAOlBC,WAAS,EAAE/E,aAAa,CAACmE,SAAd,CAAwBa,GAPjB;AAQlBC,cAAY,EAAEjF,aAAa,CAACqE,YAAd,CAA2Ba;AARvB,C;AA9BLnE,M,CAsEVoE,oB,GAAuBzF,oBAAoB,CAAC;AAC/C0F,WAAS,EAAErE,MAAM,CAAC8C,yBAD6B;AAE/CwB,eAAa,EAAEtE,MAAM,CAAC+C;AAFyB,CAAD,C;AAtEjC/C,M,CA0FVuE,wB,GAA2B5F,oBAAoB,CAAC;AACnD0F,WAAS,EAAErE,MAAM,CAACgD,6BADiC;AAEnDsB,eAAa,EAAEtE,MAAM,CAACiD;AAF6B,CAAD,C;SA1FrCjD,M;AA4Ld,IAAQC,SAAR,GAAiMD,MAAjM,CAAQC,SAAR;AAAA,IAAmB2C,mBAAnB,GAAiM5C,MAAjM,CAAmB4C,mBAAnB;AAAA,IAAwCC,uBAAxC,GAAiM7C,MAAjM,CAAwC6C,uBAAxC;AAAA,IAAiEC,yBAAjE,GAAiM9C,MAAjM,CAAiE8C,yBAAjE;AAAA,IAA4FC,6BAA5F,GAAiM/C,MAAjM,CAA4F+C,6BAA5F;AAAA,IAA2HC,6BAA3H,GAAiMhD,MAAjM,CAA2HgD,6BAA3H;AAAA,IAA0JC,iCAA1J,GAAiMjD,MAAjM,CAA0JiD,iCAA1J;;AACP,SAASlE,gBAAT","names":["createPermissionHook","Platform","UnavailabilityError","React","PermissionStatus","ExponentCamera","CameraManager","ConversionTables","ensureNativeProps","EventThrottleMs","_PICTURE_SAVED_CALLBACKS","_GLOBAL_PICTURE_ID","ensurePictureOptions","options","pictureOptions","quality","onPictureSaved","id","fastMode","ensureRecordingOptions","recordingOptions","Camera","Constants","VideoQuality","_onPictureSaved","nativeEvent","data","callback","_lastEvents","_lastEventsTimes","_onCameraReady","props","onCameraReady","_onMountError","onMountError","_onObjectDetected","type","JSON","stringify","Date","getTime","_setReference","ref","_cameraRef","OS","_cameraHandle","findNodeHandle","takePicture","getSupportedRatios","ratio","getAvailablePictureSizes","record","stopRecording","pausePreview","resumePreview","nativeProps","onBarCodeScanned","undefined","onFacesDetected","createElement","isAvailableAsync","getAvailableCameraTypesAsync","getAvailableVideoCodecsAsync","console","warn","getPermissionsAsync","requestPermissionsAsync","getCameraPermissionsAsync","requestCameraPermissionsAsync","getMicrophonePermissionsAsync","requestMicrophonePermissionsAsync","Component","Type","FlashMode","AutoFocus","WhiteBalance","VideoStabilization","VideoCodec","defaultProps","zoom","focusDepth","faceDetectorSettings","back","autoFocus","on","flashMode","off","whiteBalance","auto","useCameraPermissions","getMethod","requestMethod","useMicrophonePermissions"],"sourceRoot":"","sources":["D:/Users/georg/Desktop/MAD/SpaceBook/node_modules/expo-camera/build/Camera.js"],"sourcesContent":["import { createPermissionHook, Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as React from 'react';\nimport { findNodeHandle } from 'react-native';\nimport { PermissionStatus, } from './Camera.types';\nimport ExponentCamera from './ExponentCamera';\nimport CameraManager from './ExponentCameraManager';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\nconst EventThrottleMs = 500;\nconst _PICTURE_SAVED_CALLBACKS = {};\nlet _GLOBAL_PICTURE_ID = 1;\nfunction ensurePictureOptions(options) {\n    const pictureOptions = !options || typeof options !== 'object' ? {} : options;\n    if (!pictureOptions.quality) {\n        pictureOptions.quality = 1;\n    }\n    if (pictureOptions.onPictureSaved) {\n        const id = _GLOBAL_PICTURE_ID++;\n        _PICTURE_SAVED_CALLBACKS[id] = pictureOptions.onPictureSaved;\n        pictureOptions.id = id;\n        pictureOptions.fastMode = true;\n    }\n    return pictureOptions;\n}\nfunction ensureRecordingOptions(options) {\n    let recordingOptions = options || {};\n    if (!recordingOptions || typeof recordingOptions !== 'object') {\n        recordingOptions = {};\n    }\n    else if (typeof recordingOptions.quality === 'string') {\n        recordingOptions.quality = Camera.Constants.VideoQuality[recordingOptions.quality];\n    }\n    return recordingOptions;\n}\nfunction _onPictureSaved({ nativeEvent, }) {\n    const { id, data } = nativeEvent;\n    const callback = _PICTURE_SAVED_CALLBACKS[id];\n    if (callback) {\n        callback(data);\n        delete _PICTURE_SAVED_CALLBACKS[id];\n    }\n}\nexport default class Camera extends React.Component {\n    static async isAvailableAsync() {\n        if (!CameraManager.isAvailableAsync) {\n            throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n        }\n        return await CameraManager.isAvailableAsync();\n    }\n    static async getAvailableCameraTypesAsync() {\n        if (!CameraManager.getAvailableCameraTypesAsync) {\n            throw new UnavailabilityError('expo-camera', 'getAvailableCameraTypesAsync');\n        }\n        return await CameraManager.getAvailableCameraTypesAsync();\n    }\n    static async getAvailableVideoCodecsAsync() {\n        if (!CameraManager.getAvailableVideoCodecsAsync) {\n            throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n        }\n        return await CameraManager.getAvailableVideoCodecsAsync();\n    }\n    static Constants = {\n        Type: CameraManager.Type,\n        FlashMode: CameraManager.FlashMode,\n        AutoFocus: CameraManager.AutoFocus,\n        WhiteBalance: CameraManager.WhiteBalance,\n        VideoQuality: CameraManager.VideoQuality,\n        VideoStabilization: CameraManager.VideoStabilization || {},\n        VideoCodec: CameraManager.VideoCodec,\n    };\n    // Values under keys from this object will be transformed to native options\n    static ConversionTables = ConversionTables;\n    static defaultProps = {\n        zoom: 0,\n        ratio: '4:3',\n        focusDepth: 0,\n        faceDetectorSettings: {},\n        type: CameraManager.Type.back,\n        autoFocus: CameraManager.AutoFocus.on,\n        flashMode: CameraManager.FlashMode.off,\n        whiteBalance: CameraManager.WhiteBalance.auto,\n    };\n    /**\n     * @deprecated Use `getCameraPermissionsAync` or `getMicrophonePermissionsAsync` instead.\n     */\n    static async getPermissionsAsync() {\n        console.warn(`\"getPermissionsAsync()\" is now deprecated. Please use \"getCameraPermissionsAsync()\" or \"getMicrophonePermissionsAsync()\" instead.`);\n        return CameraManager.getPermissionsAsync();\n    }\n    /**\n     * @deprecated Use `requestCameraPermissionsAsync` or `requestMicrophonePermissionsAsync` instead.\n     */\n    static async requestPermissionsAsync() {\n        console.warn(`\"requestPermissionsAsync()\" is now deprecated. Please use \"requestCameraPermissionsAsync()\" or \"requestMicrophonePermissionsAsync()\" instead.`);\n        return CameraManager.requestPermissionsAsync();\n    }\n    static async getCameraPermissionsAsync() {\n        return CameraManager.getCameraPermissionsAsync();\n    }\n    static async requestCameraPermissionsAsync() {\n        return CameraManager.requestCameraPermissionsAsync();\n    }\n    // @needsAudit\n    /**\n     * Check or request permissions to access the camera.\n     * This uses both `requestCameraPermissionsAsync` and `getCameraPermissionsAsync` to interact with the permissions.\n     *\n     * @example\n     * ```ts\n     * const [status, requestPermission] = Camera.useCameraPermissions();\n     * ```\n     */\n    static useCameraPermissions = createPermissionHook({\n        getMethod: Camera.getCameraPermissionsAsync,\n        requestMethod: Camera.requestCameraPermissionsAsync,\n    });\n    static async getMicrophonePermissionsAsync() {\n        return CameraManager.getMicrophonePermissionsAsync();\n    }\n    static async requestMicrophonePermissionsAsync() {\n        return CameraManager.requestMicrophonePermissionsAsync();\n    }\n    // @needsAudit\n    /**\n     * Check or request permissions to access the microphone.\n     * This uses both `requestMicrophonePermissionsAsync` and `getMicrophonePermissionsAsync` to interact with the permissions.\n     *\n     * @example\n     * ```ts\n     * const [status, requestPermission] = Camera.useMicrophonePermissions();\n     * ```\n     */\n    static useMicrophonePermissions = createPermissionHook({\n        getMethod: Camera.getMicrophonePermissionsAsync,\n        requestMethod: Camera.requestMicrophonePermissionsAsync,\n    });\n    _cameraHandle;\n    _cameraRef;\n    _lastEvents = {};\n    _lastEventsTimes = {};\n    async takePictureAsync(options) {\n        const pictureOptions = ensurePictureOptions(options);\n        return await CameraManager.takePicture(pictureOptions, this._cameraHandle);\n    }\n    async getSupportedRatiosAsync() {\n        if (!CameraManager.getSupportedRatios) {\n            throw new UnavailabilityError('Camera', 'getSupportedRatiosAsync');\n        }\n        return await CameraManager.getSupportedRatios(this._cameraHandle);\n    }\n    async getAvailablePictureSizesAsync(ratio) {\n        if (!CameraManager.getAvailablePictureSizes) {\n            throw new UnavailabilityError('Camera', 'getAvailablePictureSizesAsync');\n        }\n        return await CameraManager.getAvailablePictureSizes(ratio, this._cameraHandle);\n    }\n    async recordAsync(options) {\n        if (!CameraManager.record) {\n            throw new UnavailabilityError('Camera', 'recordAsync');\n        }\n        const recordingOptions = ensureRecordingOptions(options);\n        return await CameraManager.record(recordingOptions, this._cameraHandle);\n    }\n    stopRecording() {\n        if (!CameraManager.stopRecording) {\n            throw new UnavailabilityError('Camera', 'stopRecording');\n        }\n        CameraManager.stopRecording(this._cameraHandle);\n    }\n    pausePreview() {\n        if (!CameraManager.pausePreview) {\n            throw new UnavailabilityError('Camera', 'pausePreview');\n        }\n        CameraManager.pausePreview(this._cameraHandle);\n    }\n    resumePreview() {\n        if (!CameraManager.resumePreview) {\n            throw new UnavailabilityError('Camera', 'resumePreview');\n        }\n        CameraManager.resumePreview(this._cameraHandle);\n    }\n    _onCameraReady = () => {\n        if (this.props.onCameraReady) {\n            this.props.onCameraReady();\n        }\n    };\n    _onMountError = ({ nativeEvent }) => {\n        if (this.props.onMountError) {\n            this.props.onMountError(nativeEvent);\n        }\n    };\n    _onObjectDetected = (callback) => ({ nativeEvent }) => {\n        const { type } = nativeEvent;\n        if (this._lastEvents[type] &&\n            this._lastEventsTimes[type] &&\n            JSON.stringify(nativeEvent) === this._lastEvents[type] &&\n            new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs) {\n            return;\n        }\n        if (callback) {\n            callback(nativeEvent);\n            this._lastEventsTimes[type] = new Date();\n            this._lastEvents[type] = JSON.stringify(nativeEvent);\n        }\n    };\n    _setReference = (ref) => {\n        if (ref) {\n            this._cameraRef = ref;\n            // TODO(Bacon): Unify these - perhaps with hooks?\n            if (Platform.OS === 'web') {\n                this._cameraHandle = ref;\n            }\n            else {\n                this._cameraHandle = findNodeHandle(ref);\n            }\n        }\n        else {\n            this._cameraRef = null;\n            this._cameraHandle = null;\n        }\n    };\n    render() {\n        const nativeProps = ensureNativeProps(this.props);\n        const onBarCodeScanned = this.props.onBarCodeScanned\n            ? this._onObjectDetected(this.props.onBarCodeScanned)\n            : undefined;\n        const onFacesDetected = this._onObjectDetected(this.props.onFacesDetected);\n        return (React.createElement(ExponentCamera, { ...nativeProps, ref: this._setReference, onCameraReady: this._onCameraReady, onMountError: this._onMountError, onBarCodeScanned: onBarCodeScanned, onFacesDetected: onFacesDetected, onPictureSaved: _onPictureSaved }));\n    }\n}\nexport const { Constants, getPermissionsAsync, requestPermissionsAsync, getCameraPermissionsAsync, requestCameraPermissionsAsync, getMicrophonePermissionsAsync, requestMicrophonePermissionsAsync, } = Camera;\nexport { PermissionStatus, };\n//# sourceMappingURL=Camera.js.map"]},"metadata":{},"sourceType":"module"}