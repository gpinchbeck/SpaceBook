{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport { clamp, focusWithoutScrolling, mergeProps, useGlobalListeners } from '@react-aria/utils';\nimport { getSliderThumbId, sliderIds } from \"./utils\";\nimport { useCallback, useEffect, useRef } from 'react';\nimport { useFocusable } from '@react-aria/focus';\nimport { useLabel } from '@react-aria/label';\nimport { useMove } from \"./useMove\";\nimport { isRTL } from '@react-native-aria/utils';\nexport function useSliderThumb(opts, state) {\n  var _opts$ariaLabelledby;\n\n  var index = opts.index,\n      isRequired = opts.isRequired,\n      isDisabled = opts.isDisabled,\n      validationState = opts.validationState,\n      trackLayout = opts.trackLayout,\n      inputRef = opts.inputRef;\n  var isVertical = opts.orientation === 'vertical';\n  var direction = isRTL() ? 'rtl' : undefined;\n\n  var _useGlobalListeners = useGlobalListeners(),\n      addGlobalListener = _useGlobalListeners.addGlobalListener,\n      removeGlobalListener = _useGlobalListeners.removeGlobalListener;\n\n  var labelId = sliderIds.get(state);\n\n  var _useLabel = useLabel(_objectSpread(_objectSpread({}, opts), {}, {\n    'id': getSliderThumbId(state, index),\n    'aria-labelledby': (labelId + \" \" + ((_opts$ariaLabelledby = opts['aria-labelledby']) !== null && _opts$ariaLabelledby !== void 0 ? _opts$ariaLabelledby : '')).trim()\n  })),\n      labelProps = _useLabel.labelProps,\n      fieldProps = _useLabel.fieldProps;\n\n  var value = state.values[index];\n  var focusInput = useCallback(function () {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n  var isFocused = state.focusedThumb === index;\n  useEffect(function () {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n  var stateRef = useRef(null);\n  stateRef.current = state;\n  var reverseX = direction === 'rtl';\n  var currentPosition = useRef(null);\n\n  var _useMove = useMove({\n    onMoveStart: function onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n    onMove: function onMove(_ref) {\n      var deltaX = _ref.deltaX,\n          deltaY = _ref.deltaY,\n          pointerType = _ref.pointerType;\n      var size = isVertical ? trackLayout.height : trackLayout.width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(index) * size;\n      }\n\n      if (pointerType === 'keyboard') {\n        var delta = ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) * stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(index, stateRef.current.getThumbValue(index) + delta);\n      } else {\n        var _delta = isVertical ? deltaY : deltaX;\n\n        if (isVertical || reverseX) {\n          _delta = -_delta;\n        }\n\n        currentPosition.current += _delta;\n        stateRef.current.setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd: function onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n  }),\n      moveProps = _useMove.moveProps;\n\n  state.setThumbEditable(index, !isDisabled);\n\n  var _useFocusable = useFocusable(mergeProps(opts, {\n    onFocus: function onFocus() {\n      return state.setFocusedThumb(index);\n    },\n    onBlur: function onBlur() {\n      return state.setFocusedThumb(undefined);\n    }\n  }), inputRef),\n      focusableProps = _useFocusable.focusableProps;\n\n  var currentPointer = useRef(undefined);\n\n  var onDown = function onDown(id) {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  var onUp = function onUp(e) {\n    var _e$pointerId, _e$changedTouches;\n\n    var id = (_e$pointerId = e.pointerId) !== null && _e$pointerId !== void 0 ? _e$pointerId : (_e$changedTouches = e.changedTouches) === null || _e$changedTouches === void 0 ? void 0 : _e$changedTouches[0].identifier;\n\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      'type': 'range',\n      'tabIndex': !isDisabled ? 0 : undefined,\n      'min': state.getThumbMinValue(index),\n      'max': state.getThumbMaxValue(index),\n      'step': state.step,\n      'value': value,\n      'disabled': isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'onChange': function onChange(e) {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: !isDisabled ? mergeProps(moveProps, {\n      onMouseDown: function onMouseDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDown();\n      },\n      onPointerDown: function onPointerDown(e) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDown(e.pointerId);\n      },\n      onTouchStart: function onTouchStart(e) {\n        onDown(e.changedTouches[0].identifier);\n      }\n    }) : {},\n    labelProps: labelProps\n  };\n}","map":{"version":3,"mappings":"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","names":["clamp","focusWithoutScrolling","mergeProps","useGlobalListeners","getSliderThumbId","sliderIds","useCallback","useEffect","useRef","useFocusable","useLabel","useMove","isRTL","useSliderThumb","opts","state","_opts$ariaLabelledby","index","isRequired","isDisabled","validationState","trackLayout","inputRef","isVertical","orientation","direction","undefined","addGlobalListener","removeGlobalListener","labelId","get","trim","labelProps","fieldProps","value","values","focusInput","current","isFocused","focusedThumb","stateRef","reverseX","currentPosition","onMoveStart","setThumbDragging","onMove","deltaX","deltaY","pointerType","size","height","width","getThumbPercent","delta","step","setThumbValue","getThumbValue","setThumbPercent","onMoveEnd","moveProps","setThumbEditable","onFocus","setFocusedThumb","onBlur","focusableProps","currentPointer","onDown","id","window","onUp","_e$pointerId","_e$changedTouches","e","pointerId","changedTouches","identifier","inputProps","getThumbMinValue","getThumbMaxValue","getThumbValueLabel","parseFloat","target","thumbProps","onMouseDown","button","altKey","ctrlKey","metaKey","onPointerDown","onTouchStart"],"sources":["C:/Users/georg/Documents/Coursework/SpaceBook/node_modules/@react-native-aria/slider/lib/module/useSliderThumb.web.js"],"sourcesContent":["import { clamp, focusWithoutScrolling, mergeProps, useGlobalListeners } from '@react-aria/utils';\nimport { getSliderThumbId, sliderIds } from './utils';\nimport { useCallback, useEffect, useRef } from 'react';\nimport { useFocusable } from '@react-aria/focus';\nimport { useLabel } from '@react-aria/label';\nimport { useMove } from './useMove';\nimport { isRTL } from '@react-native-aria/utils';\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(opts, state) {\n  var _opts$ariaLabelledby;\n\n  let {\n    index,\n    isRequired,\n    isDisabled,\n    validationState,\n    trackLayout,\n    inputRef\n  } = opts;\n  let isVertical = opts.orientation === 'vertical';\n  let direction = isRTL() ? 'rtl' : undefined;\n  let {\n    addGlobalListener,\n    removeGlobalListener\n  } = useGlobalListeners();\n  let labelId = sliderIds.get(state);\n  const {\n    labelProps,\n    fieldProps\n  } = useLabel({ ...opts,\n    'id': getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${(_opts$ariaLabelledby = opts['aria-labelledby']) !== null && _opts$ariaLabelledby !== void 0 ? _opts$ariaLabelledby : ''}`.trim()\n  });\n  const value = state.values[index];\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n  const isFocused = state.focusedThumb === index;\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n  const stateRef = useRef(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef(null);\n  let {\n    moveProps\n  } = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      state.setThumbDragging(index, true);\n    },\n\n    onMove({\n      deltaX,\n      deltaY,\n      pointerType\n    }) {\n      let size = isVertical ? trackLayout.height : trackLayout.width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(index) * size;\n      }\n\n      if (pointerType === 'keyboard') {\n        // (invert left/right according to language direction) + (according to vertical)\n        let delta = ((reverseX ? -deltaX : deltaX) + (isVertical ? -deltaY : -deltaY)) * stateRef.current.step;\n        currentPosition.current += delta * size;\n        stateRef.current.setThumbValue(index, stateRef.current.getThumbValue(index) + delta);\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        stateRef.current.setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n\n    onMoveEnd() {\n      state.setThumbDragging(index, false);\n    }\n\n  }); // Immediately register editability with the state\n\n  state.setThumbEditable(index, !isDisabled);\n  const {\n    focusableProps\n  } = useFocusable(mergeProps(opts, {\n    onFocus: () => state.setFocusedThumb(index),\n    onBlur: () => state.setFocusedThumb(undefined)\n  }), inputRef);\n  let currentPointer = useRef(undefined);\n\n  let onDown = id => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n  };\n\n  let onUp = e => {\n    var _e$pointerId, _e$changedTouches;\n\n    let id = (_e$pointerId = e.pointerId) !== null && _e$pointerId !== void 0 ? _e$pointerId : (_e$changedTouches = e.changedTouches) === null || _e$changedTouches === void 0 ? void 0 : _e$changedTouches[0].identifier;\n\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  }; // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n\n\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      'type': 'range',\n      'tabIndex': !isDisabled ? 0 : undefined,\n      'min': state.getThumbMinValue(index),\n      'max': state.getThumbMaxValue(index),\n      'step': state.step,\n      'value': value,\n      'disabled': isDisabled,\n      'aria-orientation': opts.orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      'onChange': e => {\n        state.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: !isDisabled ? mergeProps(moveProps, {\n      onMouseDown: e => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDown();\n      },\n      onPointerDown: e => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n\n        onDown(e.pointerId);\n      },\n      onTouchStart: e => {\n        onDown(e.changedTouches[0].identifier);\n      }\n    }) : {},\n    labelProps\n  };\n}\n//# sourceMappingURL=useSliderThumb.web.js.map"]},"metadata":{},"sourceType":"module"}