{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"type\", \"pictureSize\", \"poster\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { CodedError } from 'expo-modules-core';\nimport * as React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport createElement from 'react-native-web/dist/exports/createElement';\nimport { CameraType } from \"./Camera.types\";\nimport CameraManager from \"./ExponentCameraManager.web\";\nimport { capture } from \"./WebCameraUtils\";\nimport { PictureSizes } from \"./WebConstants\";\nimport { useWebCameraStream } from \"./useWebCameraStream\";\nimport { useWebQRScanner } from \"./useWebQRScanner\";\nvar ExponentCamera = React.forwardRef(function (_ref, ref) {\n  var _props$barCodeScanner3, _props$barCodeScanner4;\n\n  var type = _ref.type,\n      pictureSize = _ref.pictureSize,\n      poster = _ref.poster,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var video = React.useRef(null);\n  var native = useWebCameraStream(video, type, props, {\n    onCameraReady: function onCameraReady() {\n      if (props.onCameraReady) {\n        props.onCameraReady();\n      }\n    },\n    onMountError: props.onMountError\n  });\n  var isQRScannerEnabled = React.useMemo(function () {\n    var _props$barCodeScanner, _props$barCodeScanner2;\n\n    return !!((_props$barCodeScanner = props.barCodeScannerSettings) != null && (_props$barCodeScanner2 = _props$barCodeScanner.barCodeTypes) != null && _props$barCodeScanner2.includes('qr') && !!props.onBarCodeScanned);\n  }, [(_props$barCodeScanner3 = props.barCodeScannerSettings) == null ? void 0 : _props$barCodeScanner3.barCodeTypes, props.onBarCodeScanned]);\n  useWebQRScanner(video, {\n    interval: (_props$barCodeScanner4 = props.barCodeScannerSettings) == null ? void 0 : _props$barCodeScanner4.interval,\n    isEnabled: isQRScannerEnabled,\n    captureOptions: {\n      scale: 1,\n      isImageMirror: native.type === CameraType.front\n    },\n    onScanned: function onScanned(event) {\n      if (props.onBarCodeScanned) {\n        props.onBarCodeScanned(event);\n      }\n    }\n  });\n  React.useImperativeHandle(ref, function () {\n    return {\n      getAvailablePictureSizes: function getAvailablePictureSizes(ratio) {\n        return function _callee() {\n          return _regeneratorRuntime.async(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  return _context.abrupt(\"return\", PictureSizes);\n\n                case 1:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, null, null, null, Promise);\n        }();\n      },\n      takePicture: function takePicture(options) {\n        return function _callee2() {\n          var _video$current, _video$current2;\n\n          var settings;\n          return _regeneratorRuntime.async(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(!video.current || ((_video$current = video.current) == null ? void 0 : _video$current.readyState) !== ((_video$current2 = video.current) == null ? void 0 : _video$current2.HAVE_ENOUGH_DATA))) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  throw new CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');\n\n                case 2:\n                  settings = native.mediaTrackSettings;\n\n                  if (settings) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n\n                case 5:\n                  return _context2.abrupt(\"return\", capture(video.current, settings, _objectSpread(_objectSpread({}, options), {}, {\n                    onPictureSaved: function onPictureSaved(picture) {\n                      if (options.onPictureSaved) {\n                        options.onPictureSaved(picture);\n                      }\n\n                      if (props.onPictureSaved) {\n                        props.onPictureSaved({\n                          nativeEvent: {\n                            data: picture,\n                            id: -1\n                          }\n                        });\n                      }\n                    }\n                  })));\n\n                case 6:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, null, null, null, Promise);\n        }();\n      },\n      resumePreview: function resumePreview() {\n        return function _callee3() {\n          return _regeneratorRuntime.async(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (video.current) {\n                    video.current.play();\n                  }\n\n                case 1:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, null, null, null, Promise);\n        }();\n      },\n      pausePreview: function pausePreview() {\n        return function _callee4() {\n          return _regeneratorRuntime.async(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  if (video.current) {\n                    video.current.pause();\n                  }\n\n                case 1:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, null, null, null, Promise);\n        }();\n      }\n    };\n  }, [native.mediaTrackSettings, props.onPictureSaved]);\n  var isMuted = true;\n  var style = React.useMemo(function () {\n    var isFrontFacingCamera = native.type === CameraManager.Type.front;\n    return [StyleSheet.absoluteFill, styles.video, {\n      transform: isFrontFacingCamera ? [{\n        scaleX: -1\n      }] : undefined\n    }];\n  }, [native.type]);\n  return React.createElement(View, {\n    pointerEvents: \"box-none\",\n    style: [styles.videoWrapper, props.style]\n  }, React.createElement(Video, {\n    autoPlay: true,\n    playsInline: true,\n    muted: isMuted,\n    poster: poster,\n    pointerEvents: props.pointerEvents,\n    ref: video,\n    style: style\n  }), props.children);\n});\nexport default ExponentCamera;\nvar Video = React.forwardRef(function (props, ref) {\n  return createElement('video', _objectSpread(_objectSpread({}, props), {}, {\n    ref: ref\n  }));\n});\nvar styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch'\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover'\n  }\n});","map":{"version":3,"mappings":"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","names":["CodedError","React","createElement","CameraType","CameraManager","capture","PictureSizes","useWebCameraStream","useWebQRScanner","ExponentCamera","forwardRef","ref","type","pictureSize","poster","props","video","useRef","native","onCameraReady","onMountError","isQRScannerEnabled","useMemo","barCodeScannerSettings","barCodeTypes","includes","onBarCodeScanned","interval","isEnabled","captureOptions","scale","isImageMirror","front","onScanned","event","useImperativeHandle","getAvailablePictureSizes","ratio","takePicture","options","current","readyState","HAVE_ENOUGH_DATA","settings","mediaTrackSettings","onPictureSaved","picture","nativeEvent","data","id","resumePreview","play","pausePreview","pause","isMuted","style","isFrontFacingCamera","Type","StyleSheet","absoluteFill","styles","transform","scaleX","undefined","View","pointerEvents","videoWrapper","Video","autoPlay","playsInline","muted","children","create","flex","alignItems","width","height","objectFit"],"sourceRoot":"","sources":["D:/Users/georg/Desktop/MAD/SpaceBook/node_modules/expo-camera/build/ExponentCamera.web.js"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\nimport * as React from 'react';\nimport { StyleSheet, View } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\nimport { CameraType, } from './Camera.types';\nimport CameraManager from './ExponentCameraManager.web';\nimport { capture } from './WebCameraUtils';\nimport { PictureSizes } from './WebConstants';\nimport { useWebCameraStream } from './useWebCameraStream';\nimport { useWebQRScanner } from './useWebQRScanner';\nconst ExponentCamera = React.forwardRef(({ type, pictureSize, poster, ...props }, ref) => {\n    const video = React.useRef(null);\n    const native = useWebCameraStream(video, type, props, {\n        onCameraReady() {\n            if (props.onCameraReady) {\n                props.onCameraReady();\n            }\n        },\n        onMountError: props.onMountError,\n    });\n    const isQRScannerEnabled = React.useMemo(() => {\n        return !!(props.barCodeScannerSettings?.barCodeTypes?.includes('qr') && !!props.onBarCodeScanned);\n    }, [props.barCodeScannerSettings?.barCodeTypes, props.onBarCodeScanned]);\n    useWebQRScanner(video, {\n        interval: props.barCodeScannerSettings?.interval,\n        isEnabled: isQRScannerEnabled,\n        captureOptions: { scale: 1, isImageMirror: native.type === CameraType.front },\n        onScanned(event) {\n            if (props.onBarCodeScanned) {\n                props.onBarCodeScanned(event);\n            }\n        },\n        // onError: props.onMountError,\n    });\n    // const [pause, setPaused]\n    React.useImperativeHandle(ref, () => ({\n        async getAvailablePictureSizes(ratio) {\n            return PictureSizes;\n        },\n        async takePicture(options) {\n            if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n                throw new CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');\n            }\n            const settings = native.mediaTrackSettings;\n            if (!settings) {\n                throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n            }\n            return capture(video.current, settings, {\n                ...options,\n                // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n                onPictureSaved(picture) {\n                    if (options.onPictureSaved) {\n                        options.onPictureSaved(picture);\n                    }\n                    if (props.onPictureSaved) {\n                        props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n                    }\n                },\n            });\n        },\n        async resumePreview() {\n            if (video.current) {\n                video.current.play();\n            }\n        },\n        async pausePreview() {\n            if (video.current) {\n                video.current.pause();\n            }\n        },\n    }), [native.mediaTrackSettings, props.onPictureSaved]);\n    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n    const style = React.useMemo(() => {\n        const isFrontFacingCamera = native.type === CameraManager.Type.front;\n        return [\n            StyleSheet.absoluteFill,\n            styles.video,\n            {\n                // Flip the camera\n                transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n            },\n        ];\n    }, [native.type]);\n    return (React.createElement(View, { pointerEvents: \"box-none\", style: [styles.videoWrapper, props.style] },\n        React.createElement(Video, { autoPlay: true, playsInline: true, muted: isMuted, poster: poster, \n            // webkitPlaysinline\n            pointerEvents: props.pointerEvents, ref: video, style: style }),\n        props.children));\n});\nexport default ExponentCamera;\nconst Video = React.forwardRef((props, ref) => createElement('video', { ...props, ref }));\nconst styles = StyleSheet.create({\n    videoWrapper: {\n        flex: 1,\n        alignItems: 'stretch',\n    },\n    video: {\n        width: '100%',\n        height: '100%',\n        objectFit: 'cover',\n    },\n});\n//# sourceMappingURL=ExponentCamera.web.js.map"]},"metadata":{},"sourceType":"module"}